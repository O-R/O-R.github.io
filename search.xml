<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[rancher-记一次无法启动]]></title>
    <url>%2F2019%2F01%2F28%2Francher-%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[docker容器日志过多，导致磁盘空间耗尽。从而rancher server无法启动。记录关键命令。 查看容器相关信息: docker inspect 容器id 查看磁盘占用大小信息： df -h 查看目录占用总大小: du -hs 目录 列举容器日志大小：ls -lh $(find /var/lib/docker/containers/ -name *-json.log) 清除日志脚本 1234567891011121314#!/bin/shecho "==================== start clean docker containers logs =========================="logs=$(find /var/lib/docker/containers/ -name *-json.log)for log in $logs do echo "clean logs : $log" cat /dev/null &gt; $log doneecho "==================== end clean docker containers logs ==========================" 查看容器日志脚本 123456789echo "======== docker containers logs file size ========" logs=$(find /var/lib/docker/containers/ -name *-json.log) for log in $logs do ls -lh $log done]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>linux</tag>
        <tag>rancher</tag>
        <tag>devops</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于API的调度系统]]></title>
    <url>%2F2018%2F12%2F04%2F%E5%9F%BA%E4%BA%8EAPI%E7%9A%84%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[基于 Quartz.net 的接口调度设计 基于API的调度系统概念 Job：作业，拥有真正做事的方法 Execute Trigger：触发器，定义作业什么时候触发 Schedule：调度者，整合 Job 和 Tirgger ，启动单位 设计理念 通过 quartz_jobs.xml 配置 Schedule 、 Job 和 Tirgger 所有 Job 的实际业务实现由服务端开发 实现 Job 基类 ApiJob, 默认实现读取 quartz_jobs.xml 中配置的 Job，提取其中 &lt;job-data-map&gt; 节点进行接口调用 基于 ApiJob 提供了 ApiSingleThreadJob 及 ApiMultiThreadJob，普通需求可基于这两个作业配置xml。 ApiSingleThreadJob: 单线程作业，用于避免并发导致的问题 ApiMultiThreadJob：多线程作业 开发方法以下示例定义作业 SampleJob，&lt;job-type&gt; 为 ApiMultiThreadJob ，从每个小时的 0秒 开始，间隔 15秒 调用一次获取客户分布的接口 配置 quartz_jobs.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;schedule&gt; &lt;job&gt; &lt;name&gt;sampleJob&lt;/name&gt; &lt;group&gt;sampleGroup&lt;/group&gt; &lt;description&gt;Sample job for Quartz Server&lt;/description&gt; &lt;job-type&gt;Scheduler.Jobs.ApiMultiThreadJob, Scheduler&lt;/job-type&gt; &lt;durable&gt;true&lt;/durable&gt; &lt;recover&gt;false&lt;/recover&gt; &lt;job-data-map&gt; &lt;entry&gt; &lt;key&gt;ContentType&lt;/key&gt; &lt;value&gt;Json&lt;/value&gt; &lt;/entry&gt; &lt;entry&gt; &lt;key&gt;RequestUrl&lt;/key&gt; &lt;value&gt;http://127.0.0.1/api/home/customer/getDistributionList&lt;/value&gt; &lt;/entry&gt; &lt;entry&gt; &lt;key&gt;Method&lt;/key&gt; &lt;value&gt;Post&lt;/value&gt; &lt;/entry&gt; &lt;entry&gt; &lt;key&gt;Timeout&lt;/key&gt; &lt;value&gt;25&lt;/value&gt; &lt;/entry&gt; &lt;entry&gt; &lt;key&gt;JsonParam&lt;/key&gt; &lt;value&gt; &#123; "body": &#123; "longitude":113.378723, "latitude":23.129471, "ZoomLevelType":3 &#125; &#125; &lt;/value&gt; &lt;/entry&gt; &lt;/job-data-map&gt; &lt;/job&gt; &lt;trigger&gt; &lt;cron&gt; &lt;name&gt;sampleCronTrigger&lt;/name&gt; &lt;group&gt;sampleCronGroup&lt;/group&gt; &lt;description&gt;Cron trigger to simply fire sample job&lt;/description&gt; &lt;job-name&gt;sampleJob&lt;/job-name&gt; &lt;job-group&gt;sampleGroup&lt;/job-group&gt; &lt;misfire-instruction&gt;SmartPolicy&lt;/misfire-instruction&gt; &lt;cron-expression&gt;0/10 * * * * ?&lt;/cron-expression&gt; &lt;/cron&gt; &lt;/trigger&gt;&lt;/schedule&gt; 保存 quartz_jobs.xml，24小时内生效。 发布与安装Scheduler 将最终生成的 exe 封装为可通过命令行安装的可执行程序。 - 常用命令： - 安装： `Scheduler.exe install` - 卸载： `Scheduler.exe uninstall` - 开启服务：`Scheduler.exe start` - 停止服务：`Scheduler.exe stop` - 查看帮助：`Scheduler.exe help` - （第一次）发布安装步骤（后续将结合 `Jenkins` 自动构建）： 1. 停止服务 1. 文件系统方式发布，覆盖到原来的安装位置 1. 重新启动服务 - 第一次安装之后的普通发布，仅需修改配置 `quartz_jobs.xml` quartz_jobs.xml job name: 作业名称 group：分组名称 job-type：job类的程序集全名称 job-data-map：自定义 key-value 格式的数据，Scheduler 定义了如下 key,按需配置： ContentType：取值 FormUrlEncoded / Json RequestUrl: 请求的url Method: 取值 Get / Post Header:headerkey: headerkey 可替换为任何需要的 Header 键。可以有多个 headerkey 不同的 Header:headerkey Timeut: 超时时间，单位s JsonParam: json请求参数，注意 ContentType 要同时取值为 Json 12345678910111213&lt;entry&gt; &lt;key&gt;JsonParam&lt;/key&gt; &lt;value&gt; &#123; "body": &#123; "longitude":113.378723, "latitude":23.129471, "ZoomLevelType":3 &#125; &#125; &lt;/value&gt;&lt;/entry&gt; Param:paramkey: 单个请求参数，paramkey 可替换为任何需要的 参数 键。可以有多个 paramkey 不同的 Param:paramkey。注意 ContentType 要同时取值为 FormUrlEncoded 123456789101112&lt;entry&gt; &lt;key&gt;Param:grant_type&lt;/key&gt; &lt;value&gt;password&lt;/value&gt;&lt;/entry&gt;&lt;entry&gt; &lt;key&gt;Param:username&lt;/key&gt; &lt;value&gt;admin&lt;/value&gt;&lt;/entry&gt;&lt;entry&gt; &lt;key&gt;Param:password&lt;/key&gt; &lt;value&gt;123456&lt;/value&gt;&lt;/entry&gt; 其他 trigger/cron 配置参考链接 Quartz.net官方文档]]></content>
      <categories>
        <category>quartz</category>
      </categories>
      <tags>
        <tag>quartz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS]]></title>
    <url>%2F2018%2F05%2F19%2FHTTPS%2F</url>
    <content type="text"><![CDATA[一直对 HTTPS 的概念模模糊糊。本篇详细介绍以下内容： 什么是 HTTPS 数字签名是什么？ CA 机构 HTTPS 运行机制 https详解什么是HTTPSHTTPS ，也称作 HTTP over TLS 。 TLS 的前身是 SSL 。 HTTPS 和 HTTP 协议相比提供了 数据完整性：内容传输经过完整性校验 数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥 身份认证：第三方无法伪造服务端（客户端）身份，比如U盾是一种用于客户端身份认证的证书，https服务端会要求客户端将证书传送过去。 数字签名机制通常为了保证数据传输过程数据不被篡改，我们会在传输数据中加上数字签名。 数据传输前 使用摘要算法（e.g. Hash）对传输内容进行加密 ,生成摘要（digest） 使用协商好的 RSA 公钥加密上一步生成的摘要, 从而得到数字签名 接收到传输的数据后 使用 RSA 私钥解密数字签名，得到传输内容摘要 使用相同的摘要算法对传输内容加密，与上一步解密出来的摘要比对，不一致则已经被篡改 CA 机构又称为证书授权 (Certificate Authority) 机构，浏览器会内置这些 “受信任的根证书颁发机构” (即 CA ) SSL/TLS 协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。而 HTTPS 又是基于 TLS。 虽然使用数字签名机制可保证数据不被篡改，但却保证不了 公钥的可靠性 。假如遭受中间人攻击，客户端接收到中间人伪造的公钥，在客户端加密完成后，中间人再拦截传送内容，就可以使用自己的私钥截取消息。 CA 作为第三方权威机构，可以帮助客户端与服务器建立可靠的数据传输通道： 服务器向 CA 机构申请证书，CA 机构使用自己的私钥加密服务器提供的 公钥 及其他服务器信息（域名等），作为证书颁发给服务器。 浏览器会内置所有权威的 CA 机构的相关信息，比如公钥，用于解密服务器传递过来的证书，获取其中的 公钥 等信息。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。 HTTPS 运行机制 客户端向服务器发起 HTTP 请求，发送支持的通信协议（e.g. TLS ）以及用于后续生成 对话密钥 的随机数。明文传输。 服务器接收到 随机数 及 通信协议 ，同时也生成 随机数 （用于后续生成 对话密钥 ）,同时将 CA 证书发送给客户端。明文传输。 客户端接收到 随机数 及 证书后，首先匹配到对应的 CA 机构的公钥，解密出证书的颁发机构、域名、有效时间、服务器提供的公钥等信息，并一一校验。校验成功后，生成随机数（用于后续生成 对话密钥 ），并使用证书中服务器提供的公钥加密随机数，发送给服务器。 服务器接收到数据后，使用私钥解密，得到随机数，加上第一二步中的两个随机数，使用双方约定的算法生成一个 “对话密钥” ，用于加密响应与解密请求。 客户端也由以上的三个随机数，得到一个相同的 对话密钥 ，用于加密请求与解密响应。 细节 三个伪随机数保证了最终生成的密钥更接近与随机 每次请求都会生成新的 对话密钥 对称加密与解密相对于 RSA 非对称加解密，保证了性能 参考链接从 HTTP 到 HTTPS - 什么是 HTTPSHTTPS 工作原理阮一峰 - 数字签名是什么阮一峰 - SSL/TLS协议运行机制的概述]]></content>
      <categories>
        <category>webapi</category>
        <category>security</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH使用实践]]></title>
    <url>%2F2018%2F05%2F12%2FSSH%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[SSH 使用实践 如何 SSH 密钥 使用公钥访问仓库的配置 通过 SSH 克隆仓库 SSH 使用实践生成新的 SSH 密钥 注意： 本机已有RSA密钥，直接到最后一步： 4.将公钥放到 Gogs 上 Git Bash on Windows / GNU/Linux / macOS: 1ssh-keygen -t rsa -C "your.email@example.com" -b 4096 在这里 email 建议用公司邮箱 一路回车 最终会生成一个无密码的密钥。如果以后要更改密钥密码，使用命令：ssh-keygen -p &lt;keyname&gt; 复制公钥 macOS: 1pbcopy &lt; ~/.ssh/id_rsa.pub GNU/Linux (requires the xclip package): 1xclip -sel clip &lt; ~/.ssh/id_rsa.pub Windows Command Line: 1type %userprofile%\.ssh\id_rsa.pub | clip Git Bash on Windows / Windows PowerShell: 1cat ~/.ssh/id_rsa.pub | clip 将公钥放到 Gogs 上 登录 Gogs ：用户设置-&gt;SSH密钥-&gt;增加密钥 使用公钥访问仓库的配置 以下推荐 Windows 下最佳实践方式，其他系统相似 cd 到公钥所在位置 Git Bash on Windows / Windows PowerShell: 1cd ~/.ssh 添加 config 文件 Git Bash on Windows / Windows PowerShell: 1touch config 配置 config 文件 Git Bash on Windows / Windows PowerShell: 打开编辑 1vi config 添加配置 123456# Gogs KeysHost GogsHostname &lt;IP/域名&gt;User gitRSAAuthentication yesIdentityFile ~/.ssh/gitid_rsa # 记得把路径改为你的私钥路径 测试连接 1ssh -T &lt;IP/域名&gt; 22 第一次连接会做以下询问，输入 yes 123The authenticity of host '&lt;IP/域名&gt; (&lt;IP/域名&gt;)' can't be established.RSA key fingerprint is SHA256:Tgp9GgkFu6HgJZ8Cn8kkWrylKGZOXvFE6GLfuMo8eQY.Are you sure you want to continue connecting (yes/no)? 接下来会有以下提醒 123Warning: Permanently added '&lt;IP/域名&gt;' (RSA) to the list of known hosts.Hi there, You've successfully authenticated, but Gogs does not provide shell access.If this is unexpected, please log in with password and setup Gogs under another user. 到了这里，系统提醒当前密钥已经认证。 SSH 克隆仓库 命令 1git clone &lt;仓库SSH链接&gt; cd 到仓库目录下 查看仓库配置 1git config -l 配置当前仓库用户 12git config user.name &lt;用户名&gt;git config user.email &lt;用户邮箱&gt; 配置全局用户 12git config --global user.name &lt;用户名&gt;git config --global user.email &lt;用户邮箱&gt; Tip： 当前仓库用户会覆盖全局用户。如果当前仓库没有配置用户，使用全局配置的用户。 推荐 Pro Git（Git参考文档）]]></content>
      <categories>
        <category>git</category>
        <category>工具</category>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gogs在windows上的安装和配置]]></title>
    <url>%2F2018%2F05%2F12%2FGogs%E5%9C%A8windows%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[手把手描述 Gogs 在windows上的安装和配置 Gogs在windows上的安装和配置创建 git 用户 Gogs 运行应用的用户 本地用户和组 创建用户及用户组 创建 git 用户 创建 Gogs Users 用户组 本地安全策略 限制 Gogs Users 用户组登录系统 Gogs用户组-拒绝本地登录 Gogs用户组-拒绝从网络访问这台计算机 Gogs用户组-拒绝从远程桌面服务登录 Gogs 二进制安装及配置 下载压缩包 本次下载的是 非w/ mws 版本，后面再自行下载 NSSM （用于注册 Gogs 为服务，并灵活管理） 解压压缩包 下载安装 NSSM 配置 NSSM 并注册 Gogs 为 Windows 服务 Why? 方便管理，常规 cmd 为前台运行，容易被误关。 配置参考官方文档 官方文档中配置 Environment tab ，环境变量 git.exe 等的路径注意下是不是跟你系统的一一对应。 开启服务 命令 1nssm start gogs 配置外网访问（不采用反向代理） 配置入站规则 3000 端口 22 端口 配置规则同上 开启服务前确保好访问权限 Gogs Users 用户组 以及 git 用户 文件夹权限 存放 git 仓库文件夹 Gogs 安装文件夹 可能当前登录用户没有修改 Gogs 配置的权限，可自行加上 如果初始配置的时候（在后面）想使用 内置SSH服务 确保环境变量中有 ssh-keygen 的路径，可以是 git 下的路径（e.g. C:\Program Files\Git\usr\bin） Gogs 初始化配置（第一次访问） 以下是我的配置，采用 sqlite]]></content>
      <categories>
        <category>git</category>
        <category>工具</category>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>gogs</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EFCore数据迁移]]></title>
    <url>%2F2018%2F04%2F09%2F%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[EFCore数据迁移 数据迁移初始化 Code First 首先创建 DbContext ,使用以下命令添加迁移，初始化数据库。 12dotnet ef migrations add &lt;migration name&gt;dotnet ef database update Data First 根据 已经存在 的数据库，使用以下命令创建数据库上下文与实体类 1dotnet ef dbcontext scaffold &lt;connection string&gt; &lt;provider(E.g. Microsoft.EntityFrameworkCore.SqlServer)&gt; Tip ：dotnet ef --help , dotnet ef migrations --help , dotnet ef database --help , dotnet ef dbcontext --help 。这些命令可以查询其他配置。dotnet-ef命令行官方文档（.NET Core CLI） 字段的特性 FullName 没有 Set 方法，不会再数据库新建这个列 1234567891011121314151617181920212223242526272829303132333435using System;using System.Collections.Generic;using System.ComponentModel.DataAnnotations;using System.ComponentModel.DataAnnotations.Schema;namespace ContosoUniversity.Models&#123; public class Student &#123; public int ID &#123; get; set; &#125; [Required] [StringLength(50)] [Display(Name = "Last Name")] public string LastName &#123; get; set; &#125; [Required] [StringLength(50, ErrorMessage = "First name cannot be longer than 50 characters.")] [Column("FirstName")] [Display(Name = "First Name")] public string FirstMidName &#123; get; set; &#125; [DataType(DataType.Date)] [DisplayFormat(DataFormatString = "&#123;0:yyyy-MM-dd&#125;", ApplyFormatInEditMode = true)] [Display(Name = "Enrollment Date")] public DateTime EnrollmentDate &#123; get; set; &#125; [Display(Name = "Full Name")] public string FullName &#123; get &#123; return LastName + ", " + FirstMidName; &#125; &#125; public ICollection&lt;Enrollment&gt; Enrollments &#123; get; set; &#125; &#125;&#125; 导航属性，如果是集合，类型可以是 ICollection&lt;T&gt; ， HashSet&lt;T&gt; , List&lt;T&gt;。如果设置为 ICollection&lt;T&gt; ，EF 默认是一个 HashSet&lt;T&gt; 1public ICollection&lt;CourseAssignment&gt; CourseAssignments &#123; get; set; &#125; Instructor 与 OfficeAssignment 关系为 1 - 0…1，意味着讲师可能没有办公室。InstructorID 是外键，同时也是 主键 ，EF只能识别为外键， [Key] 这个特性将 InstructorID 标志为主键12345678910111213141516using System.ComponentModel.DataAnnotations;using System.ComponentModel.DataAnnotations.Schema;namespace ContosoUniversity.Models&#123; public class OfficeAssignment &#123; [Key] public int InstructorID &#123; get; set; &#125; [StringLength(50)] [Display(Name = "Office Location")] public string Location &#123; get; set; &#125; public Instructor Instructor &#123; get; set; &#125; &#125;&#125; [DatabaseGenerated(DatabaseGeneratedOption.None)] 设置主键不由数据库自动生成。在课程这个表中，CourseID 可能需要极大力度的用户自定义，比如 A课程是 1000 ，B课程是 200012345678910111213141516171819202122232425using System.Collections.Generic;using System.ComponentModel.DataAnnotations;using System.ComponentModel.DataAnnotations.Schema;namespace ContosoUniversity.Models&#123; public class Course &#123; [DatabaseGenerated(DatabaseGeneratedOption.None)] [Display(Name = "Number")] public int CourseID &#123; get; set; &#125; [StringLength(50, MinimumLength = 3)] public string Title &#123; get; set; &#125; [Range(0, 5)] public int Credits &#123; get; set; &#125; public int DepartmentID &#123; get; set; &#125; public Department Department &#123; get; set; &#125; public ICollection&lt;Enrollment&gt; Enrollments &#123; get; set; &#125; public ICollection&lt;CourseAssignment&gt; CourseAssignments &#123; get; set; &#125; &#125;&#125; 指定一个货币类型的列。2333…mysql不支持 money ，应该换为 float(9,2)12[Column(TypeName="money")]public decimal Budget &#123; get; set; &#125; 可空字段，作为外键。如果非空呢？EF默认层级删除，意味着删除外键id指向的数据，会同时删除外键所在表对应数据。 12public int? InstructorID &#123; get; set; &#125;public Instructor Administrator &#123; get; set; &#125; fluent API 取消严格的层级删除1234modelBuilder.Entity&lt;Department&gt;() .HasOne(d =&gt; d.Administrator) .WithMany() .OnDelete(DeleteBehavior.Restrict) 只能使用fluent API 设置复合主键12modelBuilder.Entity&lt;CourseAssignment&gt;() .HasKey(c =&gt; new &#123; c.CourseID, c.InstructorID &#125;); 记一次迁移失败 错误原因 Course （原来已有数据）,添加一列 DepartmentID ,此列非空，并且 Department 表还未创建。DepartmentID 默认是外键，存在外键约束。 EF在迁入的时候不知道，不知道给一个什么默认值，所以报错。 外键约束 FOREIGN KEY 约束用于预防破坏表之间连接的动作。 FOREIGN KEY 约束也能防止非法数据插入外键列，因为它 必须是它指向的那个表中的值之一。 错了怎么回滚 在数据库中迁移表添加一行记录，错的这个版本的。这里是 20180411020802_ComplexDataModel，假装这次迁移已经成功…… | MigrationId | ProductVersion | | :—–: | :—: | | 20180410142846_InitialCreat | 2.0.1-rtm-125 | | 20180410152220_MaxLengthOnNames | 2.0.1-rtm-125 | | 20180410152629_ColumnFirstName | 2.0.1-rtm-125 | | 20180410153611_ColumnSetRequied | 2.0.1-rtm-125 | | 20180411020802_ComplexDataModel | 2.0.1-rtm-125 | 执行 dotnet ef database update &lt;last version&gt; ，当然你要保证这一版本的 Down 方法里面的正确性（有些 Up 方法里的可能还没执行到，需要注释 Down 方法里部分） 1dotnet ef database update ColumnSetRequied 解决外键的问题 注释掉 Up 方法里的添加 DepartmentID 的 在创建 Department 这个表之后，添加以下 123456789migrationBuilder.Sql("INSERT INTO dbo.Department (Name, Budget, StartDate) VALUES ('Temp', 0.00, GETDATE())");// Default value for FK points to department created above, with// defaultValue changed to 1 in following AddColumn statement.migrationBuilder.AddColumn&lt;int&gt;( name: "DepartmentID", table: "Course", nullable: false, defaultValue: 1);]]></content>
      <categories>
        <category>efcore</category>
      </categories>
      <tags>
        <tag>efcore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在EFCore中查询与更新导航属性相关数据]]></title>
    <url>%2F2018%2F04%2F09%2F%E6%9F%A5%E8%AF%A2%E4%B8%8E%E6%9B%B4%E6%96%B0%E5%AF%BC%E8%88%AA%E5%B1%9E%E6%80%A7%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[在EFCore中查询与更新导航属性相关数据 查询与更新导航属性相关数据查询：预先加载、显式加载、延迟加载 预先加载(Eager Loading)的两种方式 预先加载数据库往返次数明显降低，有效提高查询效率。另一方面，在某些情况下，单独查询会更加高效。 在一个查询中预先加载所有相关数据时，可能会生成一个非常复杂的联接，SQL Server 无法有效处理该联接。 或者，如果你正在处理一组实体且只需访问其子集的导航属性，那么采用单独查询可获得更佳性能，因为预先加载所有数据后，会检索不需要的数据。 如果看重性能，那么最好测试两种方式的性能，以便做出最佳选择。 使用 Include 和 ThenInclude 123456789101112131415public IActionResult GetDepartmentsCourses()&#123; List&lt;string&gt; courseList = new List&lt;string&gt;(); //预先加载所有，使用连接查询，一次数据库往返 var departments = _context.Departments.Include(d =&gt; d.Courses); foreach (var d in departments) &#123; foreach (var c in d.Courses) &#123; courseList.Add(d.Name + "_" + c.Title); &#125; &#125; return Json(courseList);&#125; Load 可在单独查询中检索一些数据，EF 会“修正”导航属性。 1234567891011121314151617181920public IActionResult GetDepartmentsCourses2()&#123; List&lt;string&gt; courseList = new List&lt;string&gt;(); var departments = _context.Departments; foreach (var d in departments) &#123; // 单独查询，每次都会查询数据库，得到数据后将数据修正到导航属性 _context.Courses.Where(c =&gt; c.DepartmentID == d.DepartmentID).Load(); if (d.Courses == null) &#123; continue; &#125; foreach (var c in d.Courses) &#123; courseList.Add(d.Name + "_" + c.Title); &#125; &#125; return Json(courseList);&#125; 显式加载(Explicit Loading) 因为要指定属性加载，所以叫显式 123456789101112131415161718192021222324[HttpGet]public IActionResult GetDepartmentsCourses3()&#123; List&lt;string&gt; courseList = new List&lt;string&gt;(); var departments = _context.Departments; foreach (var d in departments) &#123; //Collection方法，指定一个导航属性集合，结合Load加载。查数据库。因为要指定属性加载，所以叫显式 _context.Entry(d).Collection(p =&gt; p.Courses).Load(); //Reference方法检索非collection导航属性。查数据库。 _context.Entry(d).Reference(p =&gt; p.Administrator).Load(); if (d.Courses == null) &#123; continue; &#125; foreach (var c in d.Courses) &#123; courseList.Add(d.Name + "_" + c.Title); &#125; &#125; return Json(courseList);&#125; 延迟加载（Lazy Loading） 首次读取实体时，不检索相关数据。 然而，首次尝试访问导航属性时，会自动检索导航属性所需的数据。 每次首次尝试从导航属性获取数据时，都向数据库发送查询。ps：延迟加载一般都是导航属性结合 virtual 修饰来开启。目前 2.1 preview 有延迟加载功能， 更新RowVersion 并发控制1. Timestamp 属性指定此列将包含在发送到数据库的 Update 和 Delete 命令的 Where 子句中。 该属性称为 Timestamp。 如果更愿意使用 Fluent API，可使用 IsConcurrencyToken 方法指定跟踪属性，如下例所示： 12modelBuilder.Entity&lt;Department&gt;().Property(p =&gt; p.RowVersion).IsConcurrencyToken(); 1234567891011121314151617181920212223242526272829303132using System;using System.Collections.Generic;using System.ComponentModel.DataAnnotations;using System.ComponentModel.DataAnnotations.Schema;namespace ContosoUniversity.Models&#123; public class Department &#123; public int DepartmentID &#123; get; set; &#125; [StringLength(50, MinimumLength = 3)] public string Name &#123; get; set; &#125; [DataType(DataType.Currency)] [Column(TypeName = "money")] public decimal Budget &#123; get; set; &#125; [DataType(DataType.Date)] [DisplayFormat(DataFormatString = "&#123;0:yyyy-MM-dd&#125;", ApplyFormatInEditMode = true)] [Display(Name = "Start Date")] public DateTime StartDate &#123; get; set; &#125; public int? InstructorID &#123; get; set; &#125; [Timestamp] public byte[] RowVersion &#123; get; set; &#125; public Instructor Administrator &#123; get; set; &#125; public ICollection&lt;Course&gt; Courses &#123; get; set; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091[HttpPost][ValidateAntiForgeryToken]public async Task&lt;IActionResult&gt; Edit(int? id, byte[] rowVersion)&#123; if (id == null) &#123; return NotFound(); &#125; //先查询 var departmentToUpdate = await _context.Departments.Include(i =&gt; i.Administrator).SingleOrDefaultAsync(m =&gt; m.DepartmentID == id); if (departmentToUpdate == null) &#123; //以下两行代码目的是，将新建deletedDepartment实例，并将post上来的form表单数据一一赋值到这个实体中，最终在视图显示 Department deletedDepartment = new Department(); await TryUpdateModelAsync(deletedDepartment); ModelState.AddModelError(string.Empty, "Unable to save changes. The department was deleted by another user."); ViewData["InstructorID"] = new SelectList(_context.Instructors, "ID", "FullName", deletedDepartment.InstructorID); return View(deletedDepartment); &#125; //至关重要：当 Entity Framework 创建 SQL UPDATE 命令时，该命令将包含一个 WHERE 子句，用于查找具有原始值，并且该字段设置了[Timestamp]。 _context.Entry(departmentToUpdate).Property("RowVersion").OriginalValue = rowVersion; if (await TryUpdateModelAsync&lt;Department&gt;( departmentToUpdate, "", s =&gt; s.Name, s =&gt; s.StartDate, s =&gt; s.Budget, s =&gt; s.InstructorID)) &#123; try &#123; await _context.SaveChangesAsync(); return RedirectToAction(nameof(Index)); &#125; catch (DbUpdateConcurrencyException ex) &#123; //获取受影响的 `Department` 实体 var exceptionEntry = ex.Entries.Single(); //获取用户输入的新值 var clientValues = (Department)exceptionEntry.Entity; //获取当前的数据库值 var databaseEntry = exceptionEntry.GetDatabaseValues(); if (databaseEntry == null) &#123; ModelState.AddModelError(string.Empty, "Unable to save changes. The department was deleted by another user."); &#125; else &#123; var databaseValues = (Department)databaseEntry.ToObject(); if (databaseValues.Name != clientValues.Name) &#123; ModelState.AddModelError("Name", $"Current value: &#123;databaseValues.Name&#125;"); &#125; if (databaseValues.Budget != clientValues.Budget) &#123; ModelState.AddModelError("Budget", $"Current value: &#123;databaseValues.Budget:c&#125;"); &#125; if (databaseValues.StartDate != clientValues.StartDate) &#123; ModelState.AddModelError("StartDate", $"Current value: &#123;databaseValues.StartDate:d&#125;"); &#125; if (databaseValues.InstructorID != clientValues.InstructorID) &#123; Instructor databaseInstructor = await _context.Instructors.SingleOrDefaultAsync(i =&gt; i.ID == databaseValues.InstructorID); ModelState.AddModelError("InstructorID", $"Current value: &#123;databaseInstructor?.FullName&#125;"); &#125; ModelState.AddModelError(string.Empty, "The record you attempted to edit " + "was modified by another user after you got the original value. The " + "edit operation was canceled and the current values in the database " + "have been displayed. If you still want to edit this record, click " + "the Save button again. Otherwise click the Back to List hyperlink."); //目的是忽略重新加载之前的并发冲突 departmentToUpdate.RowVersion = (byte[])databaseValues.RowVersion; ModelState.Remove("RowVersion"); &#125; &#125; &#125; ViewData["InstructorID"] = new SelectList(_context.Instructors, "ID", "FullName", departmentToUpdate.InstructorID); return View(departmentToUpdate);&#125;]]></content>
      <categories>
        <category>efcore</category>
      </categories>
      <tags>
        <tag>efcore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在EFCore中的CRUD]]></title>
    <url>%2F2018%2F04%2F08%2F%E5%9C%A8EFCore%E4%B8%AD%E7%9A%84CRUD%2F</url>
    <content type="text"><![CDATA[在EFCore中的CRUD 在EFCore中的CRUD实体的几种状态 一个实体可能会会有以下几种状态： Added： 实体在数据库中不存在。SaveChanges 方法将发起 INSERT 语法。 Unchanged： SaveChanges 方法对这种状态的实体什么都不会做。当从数据库读取实体之后，实体就是这种状态。 Modified： 实体中全部或者部分字段是这种状态时， SaveChanges 方法将发起 UPDATE 语法。 Deleted： 实体被标志位删除时， SaveChanges 方法将发起 DELETE 语法。 Detached： 实体没有被数据库上下文（database context）状态跟踪。 更改实体状态的方法 使用 Context.Entry： 12345678910111213141516//1. 修改实体Student studentToDelete = new Student() &#123; ID = id &#125;;_context.Entry(studentToDelete).State = EntityState.Deleted;await _context.SaveChangesAsync();//2. 修改字段//查询 id=1 的学生var studentToUpdate = await _context.Students.SingleOrDefaultAsync(s =&gt; s.ID == 1);//EntityState=Unchangedvar studentEntry = _context.Entry(studentToUpdate);//设置为修改状态studentEntry.Property(s =&gt; s.LastName).IsModified = true;//EntityState=ModifiedstudentEntry.Property(s =&gt; s.FirstMidName).IsModified = true;//保存更改await _context.SaveChangesAsync(); 防止加载不必要的字段 BindAttribute: Bind[&quot;Course&quot;,&quot;Grade&quot;] Student s。较适用于 Creat。 使用 TryUpdateModel ,传入一组委托参数，指定要更新的字段。这个方法会从Form表单读取数据，较适用于 Edit。 使用 View Model ，适用于 Creat 和 Edit 场景。做法：将view model 作为类型参数，接收数据，然后将其所有属性复制（可使用 AutoMapper ）到要更改的类实例中，使用 _context.Entry 方法将实体状态更改为 Unchanged ，然后再逐个将需要应用修改的属性状态 IsModified 改为 true 。最终保存到数据库。 主要方法1 不适用于 Edit 方法，Bind 会生成一个实例，将所有字段设置状态为 Modified ，未指定的字段会被清空。对于 Edit 方法，推荐先读取，再使用 TryUpdateModel 增删改1. 先读实体再修改 123456789101112131415161718192021222324[HttpPost, ActionName(&quot;Delete&quot;)][ValidateAntiForgeryToken]public async Task&lt;IActionResult&gt; DeleteConfirmed(int id)&#123; var student = await _context.Students .AsNoTracking() .SingleOrDefaultAsync(m =&gt; m.ID == id); if (student == null) &#123; return RedirectToAction(nameof(Index)); &#125; try &#123; _context.Students.Remove(student); await _context.SaveChangesAsync(); return RedirectToAction(nameof(Index)); &#125; catch (DbUpdateException /* ex */) &#123; //Log the error (uncomment ex variable name and write a log.) return RedirectToAction(nameof(Delete), new &#123; id = id, saveChangesError = true &#125;); &#125;&#125; 12345678910111213141516171819202122232425262728293031[HttpPost, ActionName("Edit")][ValidateAntiForgeryToken]public async Task&lt;IActionResult&gt; EditPost(int? id)&#123; if (id == null) &#123; return NotFound(); &#125; var studentToUpdate = await _context.Students.SingleOrDefaultAsync(s =&gt; s.ID == id); //TryUpdateModelAsync此方法传入一组委托，指定要更新的字段 if (await TryUpdateModelAsync&lt;Student&gt;( studentToUpdate, "", s =&gt; s.FirstMidName, s =&gt; s.LastName, s =&gt; s.EnrollmentDate)) &#123; try &#123; await _context.SaveChangesAsync(); return RedirectToAction(nameof(Index)); &#125; catch (DbUpdateException /* ex */) &#123; //Log the error (uncomment ex variable name and write a log.) ModelState.AddModelError("", "Unable to save changes. " + "Try again, and if the problem persists, " + "see your system administrator."); &#125; &#125; return View(studentToUpdate);&#125; 2. 先创建实体再修改 1234567891011121314151617[HttpPost][ValidateAntiForgeryToken]public async Task&lt;IActionResult&gt; DeleteConfirmed(int id)&#123; try &#123; Student studentToDelete = new Student() &#123; ID = id &#125;; _context.Entry(studentToDelete).State = EntityState.Deleted; await _context.SaveChangesAsync(); return RedirectToAction(nameof(Index)); &#125; catch (DbUpdateException /* ex */) &#123; //Log the error (uncomment ex variable name and write a log.) return RedirectToAction(nameof(Delete), new &#123; id = id, saveChangesError = true &#125;); &#125;&#125; 123456789101112131415161718192021222324public async Task&lt;IActionResult&gt; Edit(int id, [Bind("ID,EnrollmentDate,FirstMidName,LastName")] Student student)&#123; if (id != student.ID) &#123; return NotFound(); &#125; if (ModelState.IsValid) &#123; try &#123; _context.Update(student); await _context.SaveChangesAsync(); return RedirectToAction(nameof(Index)); &#125; catch (DbUpdateException /* ex */) &#123; //Log the error (uncomment ex variable name and write a log.) ModelState.AddModelError("", "Unable to save changes. " + "Try again, and if the problem persists, " + "see your system administrator."); &#125; &#125; return View(student);&#125; 3. 使用ViewModel 创建一个具有几个需要更改属性的 `ViewModel` 查询 No-tracking 查询 HttpGet 方法，在上下文生命周期内（默认是 Scoped ），不需要修改任何实体，不用通过多个查询加载导航属性 需要查询大量数据，仅有少量需要修改，禁用跟踪能大幅提高效率。在需要更新数据之前，先查询这些少量的数据，再更新。 前面已经查询出对应数据，上下文已经跟踪该数据，但想使用 attach 方式更新该数据。如果未禁用跟踪，无法以这种方式更新 跟踪查询（默认方式） 在上下文生命周期内（默认是 Scoped ）,数据会缓存，并且一直与数据库同步。 其他 数据库连接什么时候释放 数据库上下文是由 DI 注入，AddDbContext 默认生命周期为 Scope ,生命周期之后，最终会释放数据库连接等资源。Scope 意味着一次请求结束，生命周期结束。为什么？这里的 Scope 很有可能是 HttpContext.RequestServices 这个 ServiceProvider 创建的，或者其 子ServiceProvider 创建的，而 HttpContext 每次请求结束会释放，so… 多个修改之后 SaveChanges，EFCore 隐式实现事务。]]></content>
      <categories>
        <category>efcore</category>
      </categories>
      <tags>
        <tag>efcore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EFCore 初始化配置]]></title>
    <url>%2F2018%2F04%2F07%2FEFCore%20%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[EFCore基础配置与数据迁移cli EFCore 初始化配置EFCore官方教程 ef-mvc 教程 ef-mvc 教程 github 源码 基础配置 引入依赖包 MySql.Data.EntityFrameworkCore (官方，很多未完善) Pomelo.EntityFrameworkCore.MySql (Pomelo，官方推荐) 添加上下文类和实体类 12345678910111213141516171819&gt; public class SchoolContext : DbContext&gt; &#123;&gt; public SchoolContext(DbContextOptions&lt;SchoolContext&gt; options) : base(options)&gt; &#123;&gt; &gt; &#125;&gt; &gt; public DbSet&lt;Course&gt; Courses &#123; get; set; &#125;&gt; public DbSet&lt;Enrollment&gt; Enrollments &#123; get; set; &#125;&gt; public DbSet&lt;Student&gt; Students &#123; get; set; &#125;&gt; &gt; protected override void OnModelCreating(ModelBuilder modelBuilder)&gt; &#123;&gt; modelBuilder.Entity&lt;Course&gt;().ToTable("Course");&gt; modelBuilder.Entity&lt;Enrollment&gt;().ToTable("Enrollment");&gt; modelBuilder.Entity&lt;Student&gt;().ToTable("Student");&gt; &#125;&gt; &#125;&gt; 上下文的依赖注入 123456789&gt; public void ConfigureServices(IServiceCollection services)&gt; &#123;&gt; services.AddDbContext&lt;SchoolContext&gt;(options =&gt;&gt; &#123;&gt; options.UseMySQL(Configuration.GetConnectionString("DefaultConnection"));&gt; &#125;);&gt; services.AddMvc();&gt; &#125;&gt; 测试数据初始化 EnsureCreated 这个方法确保数据库被创建 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public static class DbInitializer&#123; public static void Initialize(SchoolContext context) &#123; context.Database.EnsureCreated(); // Look for any students. if (context.Students.Any()) &#123; return; // DB has been seeded &#125; var students = new Student[] &#123; new Student&#123;FirstMidName="Carson",LastName="Alexander",EnrollmentDate=DateTime.Parse("2005-09-01")&#125;, new Student&#123;FirstMidName="Meredith",LastName="Alonso",EnrollmentDate=DateTime.Parse("2002-09-01")&#125;, new Student&#123;FirstMidName="Arturo",LastName="Anand",EnrollmentDate=DateTime.Parse("2003-09-01")&#125;, new Student&#123;FirstMidName="Gytis",LastName="Barzdukas",EnrollmentDate=DateTime.Parse("2002-09-01")&#125;, new Student&#123;FirstMidName="Yan",LastName="Li",EnrollmentDate=DateTime.Parse("2002-09-01")&#125;, new Student&#123;FirstMidName="Peggy",LastName="Justice",EnrollmentDate=DateTime.Parse("2001-09-01")&#125;, new Student&#123;FirstMidName="Laura",LastName="Norman",EnrollmentDate=DateTime.Parse("2003-09-01")&#125;, new Student&#123;FirstMidName="Nino",LastName="Olivetto",EnrollmentDate=DateTime.Parse("2005-09-01")&#125; &#125;; foreach (Student s in students) &#123; context.Students.Add(s); &#125; context.SaveChanges(); var courses = new Course[] &#123; new Course&#123;CourseID=1050,Title="Chemistry",Credits=3&#125;, new Course&#123;CourseID=4022,Title="Microeconomics",Credits=3&#125;, new Course&#123;CourseID=4041,Title="Macroeconomics",Credits=3&#125;, new Course&#123;CourseID=1045,Title="Calculus",Credits=4&#125;, new Course&#123;CourseID=3141,Title="Trigonometry",Credits=4&#125;, new Course&#123;CourseID=2021,Title="Composition",Credits=3&#125;, new Course&#123;CourseID=2042,Title="Literature",Credits=4&#125; &#125;; foreach (Course c in courses) &#123; context.Courses.Add(c); &#125; context.SaveChanges(); var enrollments = new Enrollment[] &#123; new Enrollment&#123;StudentID=1,CourseID=1050,Grade=Grade.A&#125;, new Enrollment&#123;StudentID=1,CourseID=4022,Grade=Grade.C&#125;, new Enrollment&#123;StudentID=1,CourseID=4041,Grade=Grade.B&#125;, new Enrollment&#123;StudentID=2,CourseID=1045,Grade=Grade.B&#125;, new Enrollment&#123;StudentID=2,CourseID=3141,Grade=Grade.F&#125;, new Enrollment&#123;StudentID=2,CourseID=2021,Grade=Grade.F&#125;, new Enrollment&#123;StudentID=3,CourseID=1050&#125;, new Enrollment&#123;StudentID=4,CourseID=1050&#125;, new Enrollment&#123;StudentID=4,CourseID=4022,Grade=Grade.F&#125;, new Enrollment&#123;StudentID=5,CourseID=4041,Grade=Grade.C&#125;, new Enrollment&#123;StudentID=6,CourseID=1045&#125;, new Enrollment&#123;StudentID=7,CourseID=3141,Grade=Grade.A&#125;, &#125;; foreach (Enrollment e in enrollments) &#123; context.Enrollments.Add(e); &#125; context.SaveChanges(); &#125;&#125; 数据迁移 dotnet-ef命令行官方文档（.NET Core CLI） 添加命令行 Nuget 包 Microsoft.EntityFrameworkCore.Tools.DotNet 用于 dotnet-ef 命令Microsoft.DotNet.Watcher.Tools 这里用于 donet watch run，开发时保存即编译，无需重新run，这里和数据迁移无关 1234&lt;ItemGroup&gt; &lt;DotNetCliToolReference Include="Microsoft.EntityFrameworkCore.Tools.DotNet" Version="2.0.1"/&gt; &lt;DotNetCliToolReference Include="Microsoft.DotNet.Watcher.Tools" Version="2.0.0"/&gt;&lt;/ItemGroup&gt; 创建一个数据迁移类 1dotnet ef migrations add InitialCreate 应用迁移到数据库 1dotnet ef database update XXContextModelSnapshot 这个类始终与所有迁移同步，如果要撤销迁移，使用 dotnet ef migrations remove 撤销最后一个迁移，而不能删除 &lt;timestamp&gt;_&lt;migrationname&gt;.cs 文件，否则会导致此类 XXContextModelSnapshot 与剩余迁移不同步。]]></content>
      <categories>
        <category>efcore</category>
      </categories>
      <tags>
        <tag>efcore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OAuth2 协议]]></title>
    <url>%2F2018%2F04%2F07%2FOAuth2%2F</url>
    <content type="text"><![CDATA[OAuth2 认证流程 OAuth2 协议概念OAuth2 是 授权 协议。 参与者： Resource Owner（资源所有者） Resource Server（资源服务器） Third-party application（第三方） Authorization Server（授权服务器） User Agent（用户代理，如用户浏览器） 案例-谷歌云冲印： 谷歌用户小明——资源所有者 谷歌云盘——资源服务器 谷歌云冲印——第三方服务 谷歌授权服务 浏览器 模式授权码模式、简化模式、密码模式、客户端模式 授权码模式 小明访问谷歌云冲印网站，申请打印照片，云冲印将用户导向与谷歌约定的授权页面。 小明选择同意，登录谷歌账号并授权 同意之后，申请授权码： 确定校验类型，此处 response_type = “code” 验证谷歌云冲印是否在谷歌云平台注册，通过 client_id 授权，根据谷歌用户信息及 scope 生成授权码 code 根据指定的 redirect_uri 跳转到云冲印网站，同时带回参数（ code , state ） 注意 state 参数应从步骤1，由谷歌云冲印提供随机数，并在步骤2跳转回来的时候，原值带回。可有效防止CSRF（跨站请求伪造） 云冲印网站向认证服务器请求令牌 access token 校验 state ,防止 CSRF 附上 code 、 redirect_uri 、 client_id 、 client_secret 、 grant_type = “authorization_code”, 认证服务器通过client_id 、 client_secret 认证云冲印应用 认证服务器通过 code 、 redirect_uri 校验 code 认证服务器根据 code 、 grant_type 生成 access token 、token_type 、 expires_in 、 refresh_token 云冲印应用根据令牌向谷歌云盘（资源服务器）请求资源 问题思考： 为什么state 参数可以有效防止CSRF（跨站请求伪造）？ 没有state的情况，提供response_type、client_id、scope、redirect_uri，通过CSRF可以取得有效的 code。有随机 state 的话，获取到 code，可以通过 state 校验是否有效。 省略获取授权码，直接返回令牌，有什么影响？ 令牌可以直接访问资源，直接暴露出来安全程度大大下降，加上授权码的获取，由客户端应用服务器申请令牌，再请求资源，可以大幅提升安全性。 简化模式 客户端将用户导向认证服务器。 用户决定是否给于客户端授权。 假设用户给予授权，认证服务器将用户导向客户端指定的”重定向URI”，并在URI的Hash部分包含了访问令牌。 浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。 资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。 浏览器执行上一步获得的脚本，提取出令牌。 浏览器将令牌发给客户端。 密码模式 用户向客户端提供用户名和密码。 客户端将用户名和密码发给认证服务器，向后者请求令牌。 认证服务器确认无误后，向客户端提供访问令牌。 客户端模式 客户端向认证服务器进行身份认证，并要求一个访问令牌。 认证服务器确认无误后，向客户端提供访问令牌。]]></content>
      <categories>
        <category>aspnetcore</category>
        <category>授权与认证</category>
      </categories>
      <tags>
        <tag>aspnetcore</tag>
        <tag>oauth2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET Core Identity]]></title>
    <url>%2F2018%2F04%2F06%2FIdentity%2F</url>
    <content type="text"><![CDATA[ASP.NET Core Identity 源码 ASP.NET Core Identity怎么用 StartUp ConfigureServices 1234567891011121314151617public void ConfigureServices(IServiceCollection services)&#123; //EF 配置 services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt; options.UseSqlite(Configuration.GetConnectionString("DefaultConnection"))); //注入Identity依赖 services.AddIdentity&lt;ApplicationUser, IdentityRole&gt;() .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;() .AddDefaultTokenProviders(); //以下不重要....跟Identity无关 //Add application services. services.AddTransient&lt;IEmailSender, EmailSender&gt;(); services.AddMvc();&#125; Configure 1234567891011121314151617181920212223public void Configure(IApplicationBuilder app, IHostingEnvironment env)&#123; if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); app.UseDatabaseErrorPage(); &#125; else &#123; app.UseExceptionHandler("/Home/Error"); &#125; app.UseStaticFiles(); app.UseAuthentication(); app.UseMvc(routes =&gt; &#123; routes.MapRoute( name: "default", template: "&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id?&#125;"); &#125;);&#125; 三大核心对象 SignInManager： 主要处理注册登录相关业务逻辑。 e.g. 用户密码登录 1var result = await _signInManager.PasswordSignInAsync(model.Email, model.Password, model.RememberMe, lockoutOnFailure: false); 注册并登录 12345678910111213var user = new ApplicationUser &#123; UserName = model.Email, Email = model.Email &#125;;var result = await _userManager.CreateAsync(user, model.Password);if (result.Succeeded)&#123; _logger.LogInformation("User created a new account with password."); var code = await _userManager.GenerateEmailConfirmationTokenAsync(user); var callbackUrl = Url.EmailConfirmationLink(user.Id, code, Request.Scheme); await _emailSender.SendEmailConfirmationAsync(model.Email, callbackUrl); await _signInManager.SignInAsync(user, isPersistent: false); _logger.LogInformation("User created a new account with password.");&#125; UserManager： 处理用户相关添加删除，修改密码，添加删除角色等。 e.g. 创建用户 12var user = new ApplicationUser &#123; UserName = model.Email, Email = model.Email &#125;;var result = await _userManager.CreateAsync(user, model.Password); 查询用户 1var user = await _userManager.FindByIdAsync(userId); RoleManager：角色相关添加删除更新等。 原理 StartUp ConfigureServices 12345678910111213141516171819202122232425262728293031323334353637383940services.AddIdentity&lt;ApplicationUser, IdentityRole&gt;();//以上代码主要实现如下：services.AddAuthentication(options =&gt;&#123; options.DefaultAuthenticateScheme = IdentityConstants.ApplicationScheme; options.DefaultChallengeScheme = IdentityConstants.ApplicationScheme; options.DefaultSignInScheme = IdentityConstants.ExternalScheme;&#125;).AddCookie(IdentityConstants.ApplicationScheme, o =&gt;&#123; o.LoginPath = new PathString("/Account/Login"); o.Events = new CookieAuthenticationEvents &#123; OnValidatePrincipal = SecurityStampValidator.ValidatePrincipalAsync &#125;;&#125;).AddCookie(IdentityConstants.ExternalScheme, o =&gt;&#123; o.Cookie.Name = IdentityConstants.ExternalScheme; o.ExpireTimeSpan = TimeSpan.FromMinutes(5);&#125;).AddCookie(IdentityConstants.TwoFactorRememberMeScheme, o =&gt; o.Cookie.Name = IdentityConstants.TwoFactorRememberMeScheme).AddCookie(IdentityConstants.TwoFactorUserIdScheme, o =&gt;&#123; o.Cookie.Name = IdentityConstants.TwoFactorUserIdScheme; o.ExpireTimeSpan = TimeSpan.FromMinutes(5);&#125;);//..........................................................//错误信息描述services.TryAddScoped&lt;IdentityErrorDescriber&gt;();//..........................................................services.TryAddScoped&lt;UserManager&lt;TUser&gt;, AspNetUserManager&lt;TUser&gt;&gt;();services.TryAddScoped&lt;SignInManager&lt;TUser&gt;, SignInManager&lt;TUser&gt;&gt;();services.TryAddScoped&lt;RoleManager&lt;TRole&gt;, AspNetRoleManager&lt;TRole&gt;&gt;(); services.AddAuthentication 主要注入了 IAuthenticationService ， IAuthenticationHandlerProvider ， IAuthenticationSchemeProvider 几个重要的实例 1234services.TryAddScoped&lt;IAuthenticationService, AuthenticationService&gt;();services.TryAddScoped&lt;IAuthenticationHandlerProvider, AuthenticationHandlerProvider&gt;();services.TryAddSingleton&lt;IAuthenticationSchemeProvider, AuthenticationSchemeProvider&gt;(); IAuthenticationService 用来实现 HttpContext 下的几个扩展方法：Authenticate/Challenge/Forbid/SignIn/SignOut IAuthenticationSchemeProvider IAuthenticationService 会先根据 IAuthenticationSchemeProvider 获取指定的 AuthenticationScheme(认证方案) AuthenticationScheme 有三个主要属性 Name (方案名称) , DisplayName , HandlerType (AuthenticationHandler的类型) IAuthenticationHandlerProvider IAuthenticationHandlerProvider 根据指定的 AuthenticationScheme (认证方案) 的 HandlerType 属性获取到 AuthenticationHandler 以下是一个 AuthenticationService 中 SignInAsync 的实现 123456789101112131415161718192021222324252627public virtual async Task SignInAsync(HttpContext context, string scheme, ClaimsPrincipal principal, AuthenticationProperties properties)&#123; if (principal == null) &#123; throw new ArgumentNullException(nameof(principal)); &#125; if (scheme == null) &#123; //通过 AuthenticationSchemeProvider 获取 DefaultSignInScheme var defaultScheme = await Schemes.GetDefaultSignInSchemeAsync(); scheme = defaultScheme?.Name; if (scheme == null) &#123; throw new InvalidOperationException($"No authenticationScheme was specified, and there was no DefaultSignInScheme found."); &#125; &#125; //通过 AuthenticationHandlerProvider 获取到 DefaultSignInScheme 对应的AuthenticationHandlerProvider var handler = await Handlers.GetHandlerAsync(context, scheme) as IAuthenticationSignInHandler; if (handler == null) &#123; throw new InvalidOperationException($"No IAuthenticationSignInHandler is configured to handle sign in for the scheme: &#123;scheme&#125;"); &#125; await handler.SignInAsync(principal, properties);&#125; AddCookie AddCookie 会将 CookieAuthenticationHandler 作为 AuthenticationScheme 的 HandlerType 12345public static AuthenticationBuilder AddCookie(this AuthenticationBuilder builder, string authenticationScheme, string displayName, Action&lt;CookieAuthenticationOptions&gt; configureOptions)&#123; builder.Services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;IPostConfigureOptions&lt;CookieAuthenticationOptions&gt;, PostConfigureCookieAuthenticationOptions&gt;()); return builder.AddScheme&lt;CookieAuthenticationOptions, CookieAuthenticationHandler&gt;(authenticationScheme, displayName, configureOptions);&#125; 将 AuthenticationScheme 添加到 AuthenticationOptions 中。 AuthenticationOptions 会将 AuthenticationScheme 添加到 Schemes 和 SchemeMap 两个属性。AuthenticationSchemeProvider 也是通过这两个属性获取到 AuthenticationScheme 的。 123456789101112131415161718192021//// Summary:// Returns the schemes in the order they were added (important for request handling// priority)public IEnumerable&lt;AuthenticationSchemeBuilder&gt; Schemes &#123; get; &#125;//// Summary:// Maps schemes by name.public IDictionary&lt;string, AuthenticationSchemeBuilder&gt; SchemeMap &#123; get; &#125;//// Summary:// Adds an Microsoft.AspNetCore.Authentication.AuthenticationScheme.//// Parameters:// name:// The name of the scheme being added.//// configureBuilder:// Configures the scheme.public void AddScheme(string name, Action&lt;AuthenticationSchemeBuilder&gt; configureBuilder); Configure 三大核心对象 实现原理 先看下 SignManager 下 SignIn/Out 的实现 12345678910111213141516171819202122public virtual async Task SignInAsync(TUser user, AuthenticationProperties authenticationProperties, string authenticationMethod = null)&#123; var userPrincipal = await CreateUserPrincipalAsync(user); // Review: should we guard against CreateUserPrincipal returning null? if (authenticationMethod != null) &#123; userPrincipal.Identities.First().AddClaim(new Claim(ClaimTypes.AuthenticationMethod, authenticationMethod)); &#125; await Context.SignInAsync(IdentityConstants.ApplicationScheme, userPrincipal, authenticationProperties ?? new AuthenticationProperties());&#125;/// &lt;summary&gt;/// Signs the current user out of the application./// &lt;/summary&gt;public virtual async Task SignOutAsync()&#123; await Context.SignOutAsync(IdentityConstants.ApplicationScheme); await Context.SignOutAsync(IdentityConstants.ExternalScheme); await Context.SignOutAsync(IdentityConstants.TwoFactorUserIdScheme);&#125; 没错，最终都是调用 HttpContext 下的扩展方法实现，而这些扩展方法是通过 AuthenticationService 实现的， AuthenticationService 又是根据 AuthenticationScheme 中的 AuthenticationHandler 来实现。最终，这里是由 CookieAuthenticationHandler 来实现 怎么实现数据持久化 通过 Microsoft.AspNetCore.Identity.EntityFrameworkCore 1services.AddEntityFrameworkStores&lt;ApplicationDbContext&gt;() 本地化提示信息 可以在 AddIdentity 的实现中找到以下代码，IdentityErrorDescriber 用于错误提示。（e.g. 用户名和密码不匹配的提示）。 现在全都是英文提示，注意到注入方法 TryAddScoped （如果已经注入过此类型，不再注入），可以在AddIdentity 之前注入自己重写的 IdentityErrorDescriber，比如 ChineseIdentityErrorDescriber 12//错误信息描述services.TryAddScoped&lt;IdentityErrorDescriber&gt;(); 参考链接 Auth 2.0 Migration announcement]]></content>
      <categories>
        <category>aspnetcore</category>
        <category>源码揭秘</category>
      </categories>
      <tags>
        <tag>aspnetcore</tag>
        <tag>identity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AspNetCore 配置--Options]]></title>
    <url>%2F2018%2F04%2F05%2FOptions%2F</url>
    <content type="text"><![CDATA[AspNetCore Options 源码解读 Option 监控原理 OptionsMonitor 与 OptionsManager OptionOption 监控原理 ChangeToken.OnChange 12345678910111213141516171819202122232425262728293031323334353637383940public static class ChangeToken&#123;/// &lt;summary&gt;/// Registers the &lt;paramref name="changeTokenConsumer"/&gt; action to be called whenever the token produced changes./// &lt;/summary&gt;/// &lt;param name="changeTokenProducer"&gt;Produces the change token.&lt;/param&gt;/// &lt;param name="changeTokenConsumer"&gt;Action called when the token changes.&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static IDisposable OnChange(Func&lt;IChangeToken&gt; changeTokenProducer, Action changeTokenConsumer)&#123; if (changeTokenProducer == null) &#123; throw new ArgumentNullException(nameof(changeTokenProducer)); &#125; if (changeTokenConsumer == null) &#123; throw new ArgumentNullException(nameof(changeTokenConsumer)); &#125; Action&lt;object&gt; callback = null; callback = (s) =&gt; &#123; // The order here is important. We need to take the token and then apply our changes BEFORE // registering. This prevents us from possible having two change updates to process concurrently. // // If the token changes after we take the token, then we'll process the update immediately upon // registering the callback. var t = changeTokenProducer(); try &#123; changeTokenConsumer(); &#125; finally // We always want to ensure the callback is registered &#123; t.RegisterChangeCallback(callback, null); &#125; &#125;; return changeTokenProducer().RegisterChangeCallback(callback, null);&#125; 以下每个类都会有几个相同属性或方法： _reloadToken : ConfigurationReloadToken 属性 12345678910111213141516171819202122232425262728public class ConfigurationReloadToken : IChangeToken&#123; private CancellationTokenSource _cts = new CancellationTokenSource(); /// &lt;summary&gt; /// Indicates if this token will proactively raise callbacks. Callbacks are still guaranteed to be invoked, eventually. /// &lt;/summary&gt; public bool ActiveChangeCallbacks =&gt; true; /// &lt;summary&gt; /// Gets a value that indicates if a change has occurred. /// &lt;/summary&gt; public bool HasChanged =&gt; _cts.IsCancellationRequested; /// &lt;summary&gt; /// Registers for a callback that will be invoked when the entry has changed. &lt;see cref="Microsoft.Extensions.Primitives.IChangeToken.HasChanged"/&gt; /// MUST be set before the callback is invoked. /// &lt;/summary&gt; /// &lt;param name="callback"&gt;The callback to invoke.&lt;/param&gt; /// &lt;param name="state"&gt;State to be passed into the callback.&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public IDisposable RegisterChangeCallback(Action&lt;object&gt; callback, object state) =&gt; _cts.Token.Register(callback, state); /// &lt;summary&gt; /// Used to trigger the change token when a reload occurs. /// &lt;/summary&gt; public void OnReload() =&gt; _cts.Cancel();&#125; GetReloadToken() : IChangeToken 方法 12345public IChangeToken GetReloadToken()&#123; //永远返回最新的 _reloadToken ，只要调用 OnReload() 就会更新 return _reloadToken;&#125; OnReload() : void 方法 12345678protected void OnReload()&#123; //生成新的ConfigurationReloadToken，赋值到 _reloadToken，并将原来的 _reloadToken 赋值给 previousToken var previousToken = Interlocked.Exchange(ref _reloadToken, new ConfigurationReloadToken()); //调用原来的 ConfigurationReloadToken 中 OnReload，会触发已经注册过回调函数 previousToken.OnReload();&#125; FileConfigurationProvider 123456ChangeToken.OnChange(() =&gt; Source.FileProvider.Watch(Source.Path),() =&gt; &#123; Thread.Sleep(Source.ReloadDelay); Load(reload: true);&#125;); FileConfigurationProvider 初始化时会在 ChangeToken 的 changeTokenProducer 传一个委托 () =&gt; Source.FileProvider.Watch(Source.Path) ,这个委托会中会实现一个 FileSystemWatcher 类，这个监控类有 OnChanged/OnCreated/OnDeleted/OnError/OnRenamed 这些事件。 e.g. OnChanged 事件,在文件修改的时候触发，其中 CancelToken(&lt;matchtoken&gt;) 是执行取消的。取消同时就会触发已经注册的回调，回调做两件事（看 ChangeToken.Onchange 中的 callback）：其一，执行 changeTokenConsumer 委托。其二，获取最新的 reloadToken ，给它注册上取消回调 。这里取消的回调就是： 1234() =&gt; &#123; Thread.Sleep(Source.ReloadDelay); Load(reload: true);&#125;) ConfigurationRoot 12345foreach (var p in providers)&#123; p.Load(); ChangeToken.OnChange(() =&gt; p.GetReloadToken(), () =&gt; RaiseChanged());&#125; ConfigurationRoot 初始化的时候，会给所有 ConfigurationProvider 的 reloadToken 注册一个 callback，这个 callback 做两件事：其一， 执行 changeTokenConsumer 委托。其二，获取最新的 reloadToken ，给它注册上取消回调 。 这里 changeTokenConsumer 委托是 () =&gt; RaiseChanged() , changeTokenProducer 委托是 () =&gt; p.GetReloadToken() 在 FileConfigurationProvider 这一步时，文件更改最终会消费其 changeTokenConsumer ,其中有个方法 Load(reload: true)，此方法会调用 FileConfigurationProvider 中的 OnReload() 方法。 前面我们说过，OnReload() 方法会生成一个新的 reloadToken ，同时调用之前的 reloadToken 的 OnReload ，从而触发已经注册过回调函数。 FileConfigurationProvider 的取消回调函数哪里来的？？ ConfigurationRoot 的初始化构造函数会注入 changeTokenConsumer ： () =&gt; RaiseChanged(), 这个委托会调用 OnReload ，从而激活下游。 以上是整个监控链的构造过程，修改文件是否修改Options还有一个重要因素 reloadOnChange,此属性来自 ConfigurationSource。 1234var configuration = new ConfigurationBuilder() .SetBasePath(Directory.GetCurrentDirectory()) .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true) .Build(); OptionsMonitor 与 OptionsManager构造函数中通过以下代码，于上游的 ConfigurationRoot 建立联系。 1234ChangeToken.OnChange&lt;string&gt;( () =&gt; source.GetChangeToken(), (name) =&gt; InvokeChanged(name), source.Name); changeTokenProducer : () =&gt; source.GetChangeToken() ,获取到的是 IConfiguration 的 IChangeToken。换句话说，IConfiguration 上的取消回调函数来自于这里的 changeTokenConsumer 委托：(name) =&gt; InvokeChanged(name) OptionsManager&lt;TOptions&gt; 是以 Singleton 生命周期注入的，每次实例化都会 new 一个 OptionsCache OptionsManager&lt;TOptions&gt; 的取值是通过 Get(name) 方法， Get 是通过 cache 的 GetorAdd(name,()=&gt;_factory.Create(name)。 _factory 即 OptionsFactory, Create 方法的实现是获取所有 IConfigureOptions&lt;TOptions&gt; 和 IPostConfigureOptions&lt;TOptions&gt; ,执行其中的 Configure 方法 , 从而执行所有委托 1234567891011121314151617181920212223242526public OptionsFactory(IEnumerable&lt;IConfigureOptions&lt;TOptions&gt;&gt; setups, IEnumerable&lt;IPostConfigureOptions&lt;TOptions&gt;&gt; postConfigures)&#123; _setups = setups; _postConfigures = postConfigures;&#125;public TOptions Create(string name)&#123; var options = new TOptions(); foreach (var setup in _setups) &#123; if (setup is IConfigureNamedOptions&lt;TOptions&gt; namedSetup) &#123; namedSetup.Configure(name, options); &#125; else if (name == Options.DefaultName) &#123; setup.Configure(options); &#125; &#125; foreach (var post in _postConfigures) &#123; post.PostConfigure(name, options); &#125; return options;&#125; cache 的 GetorAdd 封装了一个支持并发的字典 ConcurrentDictionary&lt;string, Lazy&lt;TOptions&gt;&gt; ,最后是将要执行的委托 ()=&gt;_factory.Create(name) , GetOrAdd 到这个字典中去。 Lazy 保证了多线程，并发 GetOrAdd 同一个 Key ，虽然可能会已经有多个相同委托产生，但延迟执行最后只取第一个执行的委托的返回值 TOptions 。 与 OptionsManager 相比 ，OptionsMonitor 更加灵活，首先 OptionsMonitor 下的 _cache 是由生命周期 Singleton 注入的 OptionsCache ，相较于 OptionsManager 自己实例化的私有变量 _cache，它可以随时随地清除缓存，移除新增等。 可以通过 OptionsMonitor.OnChange(Action&lt;TOptions, string&gt; listener) 注册事件，OptionsMonitor 有一个事件类型的字段 _onChange , 在 IConfigurationRoot reload 的时候触发事件。 总之， 虽然两个都是全局的缓存。但是 OptionsMonitor 更加灵活，可注册事件，并且随着绑定的 IConfigurationRoot 实例的变化而改变，并且触发事件，还可以管理缓存。 OptionsMonitor 是全局 Singleton ,通过 event 注册，并发会线程安全吗？？]]></content>
      <categories>
        <category>aspnetcore</category>
        <category>源码揭秘</category>
      </categories>
      <tags>
        <tag>aspnetcore</tag>
        <tag>options</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AspNetCore 请求处理管道--WebHost]]></title>
    <url>%2F2018%2F04%2F04%2FPipeline%2F</url>
    <content type="text"><![CDATA[AspNetCore 请求处理流程 ASP.NET Core 请求处理管道思维导图 其他 中间件 中间件规范 应该定义成实例类，不能定义成静态类。 具有一个有效的公共构造函数。这个构造函数的第一个参数类型必须为RequestDelegate，代表对请求的后续操作（可以视为下一个注册的中间件），至于后续参数的个数和类型则不作要求。后续参数可以被依赖注入 针对请求的处理定义在一个名为Invoke的公共实例方法，其返回类型为Task。该方法的第一个参数类型为HttpContext，代表当前HTTP上下文。我们可以为这个方法定义任意数量和类型的后续参数，当这个方法被执行的时候，系统将会采用依赖注入的方式提供响应的服务来为这个参数赋值。 示例： 1234567891011121314151617181920public class ContentMiddleare&#123; public RequestDelegate _next; public byte[] _content; public string _contentType; public ContentMiddleare(RequestDelegate next, byte[] content, string contentType) &#123; _next = next; _content = content; _contentType = contentType; &#125; public async Task Invoke(HttpContext context, ILoggerFactory loggerFactory) &#123; loggerFactory.CreateLogger&lt;ContentMiddleare&gt;().LogInformation($"Write content (&#123;_contentType&#125;)"); context.Response.ContentType = _contentType; await context.Response.Body.WriteAsync(_content,0, _content.Length); &#125;&#125; IMiddleware、IMiddlewareFactory 第三方 DI框架 整合 规范 标配：Startup 中带返回值 IServiceProvider 的 ConfigureServices 1234public IServiceProvider ConfigureServices(IServiceCollection svcs)&#123; return Cat.Instance.Register(svcs.AddSingleton&lt;IBaz, Baz&gt;());&#125;]]></content>
      <categories>
        <category>aspnetcore</category>
        <category>源码揭秘</category>
      </categories>
      <tags>
        <tag>aspnetcore</tag>
        <tag>webhost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AspNetCore 配置--Configuration]]></title>
    <url>%2F2018%2F04%2F03%2FConfiguration%2F</url>
    <content type="text"><![CDATA[通过UML分析 Configuration 初始化的过程 Configuration初始化的过程 入口启动 1234public static IWebHost BuildWebHost(string[] args) =&gt; WebHost.CreateDefaultBuilder(args) .UseStartup&lt;Startup&gt;() .Build(); Configuration 的初始化位于 IWebHostBuilder.Build() 方法中，其中有一个方法: BuildCommonServices 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public IWebHost Build()&#123; //...............................省略................................// //*******************************************************************// var hostingServices = BuildCommonServices(out var hostingStartupErrors); //*******************************************************************// var applicationServices = hostingServices.Clone(); var hostingServiceProvider = hostingServices.BuildServiceProvider(); AddApplicationServices(applicationServices, hostingServiceProvider); var host = new WebHost( applicationServices, hostingServiceProvider, _options, _config, hostingStartupErrors); host.Initialize(); return host;&#125;private IServiceCollection BuildCommonServices(out AggregateException hostingStartupErrors)&#123; //...............................省略................................// //*******************************************************************// var builder = new ConfigurationBuilder() .SetBasePath(_hostingEnvironment.ContentRootPath) .AddInMemoryCollection(_config.AsEnumerable()); foreach (var configureAppConfiguration in _configureAppConfigurationBuilderDelegates) &#123; configureAppConfiguration(_context, builder); &#125; var configuration = builder.Build(); //*******************************************************************// //至此Configure初始化完毕 //...............................省略................................// foreach (var configureServices in _configureServicesDelegates) &#123; configureServices(_context, services); &#125; return services;&#125; ConfigurationBuilder.Build() UML 分析]]></content>
      <categories>
        <category>aspnetcore</category>
        <category>源码揭秘</category>
      </categories>
      <tags>
        <tag>aspnetcore</tag>
        <tag>configuration</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos_配置rabbitmq]]></title>
    <url>%2F2018%2F03%2F20%2Fcentos_%E9%85%8D%E7%BD%AErabbitmq%2F</url>
    <content type="text"><![CDATA[详述 rabbitmq 在 centos 的配置 配置rabbitmqrabbitmq_management (Web UI)rabbitmq 提供了一个 Web UI 管理后台插件。可以用以下命令开启：1rabbitmq-plugins enable rabbitmq_management 访问网址是：http://server-name:15672/rabbitmq 提供了一个默认管理员，账号：guest，密码：guest。此账号只能在局域网内访问：http://127.0.0.1:15672/ 注意： 版本在3.0之前端口是：55672更多说明参考：Management Plugin 配置方式 环境变量（Environment Variables） 优先从 shell 中获取系统环境变量 从配置环境获取， Windows 上是 rabbitmq-env-conf.bat , Linux 上是 rabbitmq-env.conf 配置文件（Configuration File(s)）,某些配置没法采用 sysctl format （第二种方式）来配置的可以采用在 advanced.config 中配置。在RabbitMQ 3.7.0之前 advanced.config 是命名为 rabbitmq.config ，这是一个标准的 Erlang 配置文件。 advanced.config，advanced.config.example rabbitmq.conf，rabbitmq.conf.example rabbitmqctl 用于管理 virtual hosts, users and permissions. advanced.config、rabbitmq.conf 和 rabbitmq-env.conf 默认位置 Generic UNIX - $RABBITMQ_HOME/etc/rabbitmq/ Debian - /etc/rabbitmq/ RPM - /etc/rabbitmq/ Mac OSX (Homebrew) - ${install_prefix}/etc/rabbitmq/, the Homebrew prefix is usually /usr/local Windows - %APPDATA%\RabbitMQ\ advanced.config、rabbitmq.conf 和 rabbitmq-env.conf 默认不存在，可以在以上位置创建。 关于配置文件位置具体参考：config-location 环境变量的配置（简单介绍 rabbitmq-env.conf ） 说明 rabbitmq-env.conf 包含了用于RabbitMQ环境变量的设置。RabbitMQ 在获取环境变量的时候首先从 shell 中获取，其次 rabbitmq-env.conf ，最后是启动脚本（startup script）中的默认值。只要前面获取到的值为空，则继续往后取值，否则取其值。 在配置文件 rabbitmq-env.conf 中，变量名会去掉前缀 RABBITMQ_ , 如 RABBITMQ_NODE_PORT -&gt; NODE_PORT 举例（重写节点名称”rabbit” -&gt; “hare”） 1234# I am a complete rabbitmq-env.conf file.# Comment lines start with a hash character.# This is a /bin/sh script file - use ordinary envt var syntaxNODENAME=hare RabbitMQ 环境变量 默认位置 Name Location RABBITMQ_BASE (Not used - Windows only) RABBITMQ_CONFIG_FILE ${install_prefix}/etc/rabbitmq/rabbitmq RABBITMQ_MNESIA_BASE ${install_prefix}/var/lib/rabbitmq/mnesia RABBITMQ_MNESIA_DIR $RABBITMQ_MNESIA_BASE/$RABBITMQ_NODENAME RABBITMQ_LOG_BASE ${install_prefix}/var/log/rabbitmq RABBITMQ_LOGS $RABBITMQ_LOG_BASE/$RABBITMQ_NODENAME.log RABBITMQ_SASL_LOGS $RABBITMQ_LOG_BASE/$RABBITMQ_NODENAME-sasl.log RABBITMQ_PLUGINS_DIR /usr/lib/rabbitmq/plugins:$RABBITMQ_HOME/plugins Note that /usr/lib/rabbitmq/plugins is used only when RabbitMQ is installed into the standard (default) location. RABBITMQ_ENABLED_PLUGINS_FILE ${install_prefix}/etc/rabbitmq/enabled_plugins RABBITMQ_PID_FILE $RABBITMQ_MNESIA_DIR.pid 配置 rabbitmq.conf 开启外网访问 Web UI firewall-cmd 开启 15672 端口 12345678910111213141516171819202122232425262728293031323334 &gt; [root@localhost rabbitmq]# firewall-cmd --list-all &gt; public (active) &gt; target: default &gt; icmp-block-inversion: no &gt; interfaces: ens32 &gt; sources: &gt; services: ssh dhcpv6-client &gt; ports: &gt; protocols: &gt; masquerade: no &gt; forward-ports: &gt; source-ports: &gt; icmp-blocks: &gt; rich rules: &gt; &gt; [root@localhost rabbitmq]# firewall-cmd --permanent --add-port=15672/tcp &gt; success &gt; [root@localhost rabbitmq]# firewall-cmd --reload &gt; success &gt; [root@localhost rabbitmq]# firewall-cmd --list-all &gt; public (active) &gt; target: default &gt; icmp-block-inversion: no &gt; interfaces: ens32 &gt; sources: &gt; services: ssh dhcpv6-client &gt; ports: 15672/tcp &gt; protocols: &gt; masquerade: no &gt; forward-ports: &gt; source-ports: &gt; icmp-blocks: &gt; rich rules: &gt; 取消注释 编辑 rabbitmq.conf ，取消注释 loopback_users.guest = false 12345&gt; [root@localhost rabbitmq]# cd /etc/rabbitmq/&gt; [root@localhost rabbitmq]# ls&gt; enabled_plugins rabbitmq.conf rabbitmq.config.bak&gt; [root@localhost rabbitmq]# vim rabbitmq.conf&gt; 重启 123&gt; /sbin/service rabbitmq-server stop&gt; /sbin/service rabbitmq-server start&gt;]]></content>
      <categories>
        <category>linux</category>
        <category>rabbitmq</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos_安装rabbitmq]]></title>
    <url>%2F2018%2F03%2F19%2Fcentos_%E5%AE%89%E8%A3%85rabbitmq%2F</url>
    <content type="text"><![CDATA[详述 CentOS 上 rabbitmq 的环境安装 安装rabbitmq安装 erlangrabbitmq 安装 依赖于 erlang ，所以要先安装 erlang 。erlang 有多种版本，这里采用 rabbitmq 提供的 erlang-rpm (Zero-dependency Erlang RPM for RabbitMQ) 添加 .repo 配置文件 1234567891011&gt; [root@localhost ~]# cd /etc/yum.repos.d/&gt; [root@localhost yum.repos.d]# vi rabbitmq-erlang.repo&gt; # In /etc/yum.repos.d/rabbitmq-erlang.repo&gt; [rabbitmq-erlang]&gt; name=rabbitmq-erlang&gt; baseurl=https://dl.bintray.com/rabbitmq/rpm/erlang/20/el/7&gt; gpgcheck=1&gt; gpgkey=https://dl.bintray.com/rabbitmq/Keys/rabbitmq-release-signing-key.asc&gt; repo_gpgcheck=0&gt; enabled=1&gt; 安装 erlang 12&gt; [root@localhost yum.repos.d]# yum install erlang -y&gt; 测试 erlang 是否安装成功 123456&gt; [root@localhost yum.repos.d]# erl -v&gt; Erlang/OTP 20 [erts-9.3] [source] [64-bit] [smp:1:1] [ds:1:1:10] [async-threads:10] [hipe] &gt; [kernel-poll:false]&gt; &gt; Eshell V9.3 (abort with ^G)&gt; 1&gt; &gt; 安装 RabbitMQ Server 下载 rabbitmq-server-3.7.4-1.el7.noarch.rpm 12&gt; [root@localhost yum.repos.d]# wget &gt; https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.4/rabbitmq-server-3.7.4-1.el7. noarch.rpm&gt; 安装 123&gt; [root@localhost yum.repos.d]# rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc&gt; [root@localhost yum.repos.d]# yum install rabbitmq-server-3.7.4-1.el7.noarch.rpm -y&gt; 启动服务 开机自启动12&gt; chkconfig rabbitmq-server on &gt; 开启与停止123&gt; /sbin/service rabbitmq-server start&gt; /sbin/service rabbitmq-server stop&gt;]]></content>
      <categories>
        <category>linux</category>
        <category>rabbitmq</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos_yum源配置]]></title>
    <url>%2F2018%2F03%2F17%2Fcentos_yum%E6%BA%90%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[详述 CentOS7 yum 源配置 yum 源配置在vm中安装了 CentOS7 minimal ，既没有 wget 又没有 yum 源，很尴尬。解决方法： 配置静态IP 使用阿里云Yum源，更改Yum仓库。 配置静态IP [root@localhost ~]# cd /etc/sysconfig/network-scripts/[root@localhost network-scripts]# vim ifcfg-ens32 1234567891011&gt; TYPE=Ethernet&gt; BOOTPROTO=static ##设置为静态IP模式&gt; NAME=ens32&gt; UUID=2626dc0c-2aa4-471f-81b4-794d83e727ac&gt; DEVICE=ens32&gt; ONBOOT=yes&gt; IPADDR=192.168.0.111 ## IP地址&gt; NETMASK=255.255.255.0 ## 必填&gt; GATEWAY=192.168.0.1 ## 网关&gt; DNS1=192.168.0.1 ## DNS解析&gt; [root@localhost network-scripts]# systemctl restart network[root@localhost network-scripts]# ping -c 4 www.baidu.comPING www.a.shifen.com (163.177.151.110) 56(84) bytes of data.64 bytes from 163.177.151.110 (163.177.151.110): icmp_seq=1 ttl=55 time=6.72 ms64 bytes from 163.177.151.110 (163.177.151.110): icmp_seq=2 ttl=55 time=6.55 ms64 bytes from 163.177.151.110 (163.177.151.110): icmp_seq=3 ttl=55 time=6.66 ms64 bytes from 163.177.151.110 (163.177.151.110): icmp_seq=4 ttl=55 time=6.16 ms — www.a.shifen.com ping statistics —4 packets transmitted, 4 received, 0% packet loss, time 3006msrtt min/avg/max/mdev = 6.166/6.526/6.722/0.224 ms 更改Yum仓库（有 curl ） 使用 curl http://mirrors.aliyun.com/repo/Centos-7.repo 获取这个文件 备份并用第一步的内容替换系统的repo文件 1234&gt; [root@localhost ~]# cd /etc/yum.repos.d/&gt; [root@localhost yum.repos.d]# cp CentOS-Base.repo CentOS-Base.repo.bak&gt; [root@localhost yum.repos.d]# vim CentOS-Base.repo&gt; 按第一步的内容修改 CentOS-Base.repo 执行yum源更新命令 1234&gt; yum clean all &gt; yum makecache &gt; yum update&gt; 更改Yum仓库 手动下载repo文件 http://mirrors.aliyun.com/repo/Centos-7.repo 获取到base 部分 123456789&gt; [base]&gt; name=CentOS-$releasever - Base - mirrors.aliyun.com&gt; failovermethod=priority&gt; baseurl=http://mirrors.aliyun.com/centos/$releasever/os/$basearch/&gt; http://mirrors.aliyuncs.com/centos/$releasever/os/$basearch/&gt; #mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os&gt; gpgcheck=1&gt; gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7&gt; 备份并修改系统的repo文件 1234567&gt; [root@localhost ~]# cd /etc/yum.repos.d/&gt; [root@localhost yum.repos.d]# cp CentOS-Base.repo CentOS-Base.repo.bak &gt; [root@localhost yum.repos.d]# ls&gt; Centos-7.repo CentOS-Base.repo.bak CentOS-Debuginfo.repo CentOS-Media.repo CentOS-Vault.repo&gt; CentOS-Base.repo CentOS-CR.repo CentOS-fasttrack.repo CentOS-Sources.repo&gt; [root@localhost yum.repos.d]# vim CentOS-Base.repo&gt; 按第一步的[base]修改[base]部分 执行yum源更新命令 1234&gt; yum clean all &gt; yum makecache &gt; yum update&gt; 现在可以安装 wget 了 12345&gt; [root@localhost ~]# cd /etc/yum.repos.d/&gt; [root@localhost yum.repos.d]# yum install wget -y&gt; [root@localhost yum.repos.d]# wget http://mirrors.aliyun.com/repo/Centos-7.repo&gt; [root@localhost yum.repos.d]# cp Centos-7.repo CentOS-Base.repo&gt; 最后重复执行第三步。]]></content>
      <categories>
        <category>linux</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库基本概念]]></title>
    <url>%2F2018%2F03%2F15%2F%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[数据库范式基本概念 范式数据库基本概念 实体：现实世界中客观存在并可以被区别的事物。比如“一个学生”、“一本书”、“一门课”等等。值得强调的是这里所说的“事物”不仅仅是看得见摸得着的“东西”，它也可以是虚拟的，不如说“老师与学校的关系”。 属性：教科书上解释为：“实体所具有的某一特性”，由此可见，属性一开始是个逻辑概念，比如说，“性别”是“人”的一个属性。在关系数据库中，属性又是个物理概念，属性可以看作是“表的一列”。 元组：表中的一行就是一个元组。 分量：元组的某个属性值。在一个关系数据库中，它是一个操作原子，即关系数据库在做任何操作的时候，属性是“不可分的”。否则就不是关系数据库了。 码：表中可以唯一确定一个元组的某个属性（或者属性组），如果这样的码有不止一个，那么大家都叫候选码，我们从候选码中挑一个出来做老大，它就叫主码。 全码：如果一个码包含了所有的属性，这个码就是全码。 主属性：一个属性只要在任何一个候选码中出现过，这个属性就是主属性。 非主属性：与上面相反，没有在任何候选码中出现过，这个属性就是非主属性。 外码：一个属性（或属性组），它不是码，但是它别的表的码，它就是外码。 候选码： 若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何真子集都不能再标识，则称该属性组为（超级码）候选码。 范式的概念 第一范式（1NF）：属性不可分（1NF是对属性的原子性约束，要求属性具有原子性，不可再分解） 第二范式（2NF）：符合1NF，并且非主属性完全依赖于码。（2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性，更通俗说有主键ID） 第三范式（3NF）：符合2NF，并且，消除传递依赖。（3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余） BCNF：符合3NF，并且，主属性不依赖于主属性。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步编程基础]]></title>
    <url>%2F2018%2F03%2F14%2F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[异步编程基础 异步编程基础 死锁 ConfigureAwait 的作用？ 试图继续回夺取的原始上下文，则为 true；否则为 false。 什么情况下会造成死锁？ 同步方法中调用异步方法，异步方法或异步方法中的异步方法(指 Task )，没有使用 .ConfigureAwait(false)。 123456789101112131415161718192021&gt; [Route("")]&gt; [HttpGet]&gt; public string Index()&gt; &#123;&gt; System.Diagnostics.Debug.WriteLine("Thread.CurrentThread.ManagedThreadId1:" + Thread.CurrentThread.ManagedThreadId);&gt; var result = Test3().Result;&gt; System.Diagnostics.Debug.WriteLine("Thread.CurrentThread.ManagedThreadId4:" + Thread.CurrentThread.ManagedThreadId);&gt; return result;&gt; &#125;&gt;&gt; public static async Task&lt;string&gt; Test3()&gt; &#123;&gt; System.Diagnostics.Debug.WriteLine("Thread.CurrentThread.ManagedThreadId2:" + Thread.CurrentThread.ManagedThreadId);&gt; using (var client = new HttpClient())&gt; &#123;&gt; var response = await client.GetAsync(url);&gt; System.Diagnostics.Debug.WriteLine("Thread.CurrentThread.ManagedThreadId3:" + Thread.CurrentThread.ManagedThreadId);&gt; return await response.Content.ReadAsStringAsync();&gt; &#125;&gt; &#125;&gt; 输出结果: 123&gt; Thread.CurrentThread.ManagedThreadId1:5&gt; Thread.CurrentThread.ManagedThreadId2:5&gt; Test3().Result会阻塞主线程，等待Test3()中的线程执行完毕，会到主线程。Test3()中 await client.GetAsync(url), 会尝试获取当前线程上下文，这个上下文正在被主线程占用，并未释放，至此互相等待引起死锁。更正为 await client.GetAsync(url).ConfigureAwait(false)，会从线程池获取线程上下文，可避免这种情况。 .ConfigureAwait(false)，从线程池里获取新的线程，取消对SynchronizationContext的竞争。 .ConfigureAwait(true)，与主线程竞争SynchronizationContext 特别注意：.net core 取消了SynchronizationContext，不再有死锁]]></content>
      <categories>
        <category>C#基础</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程概念]]></title>
    <url>%2F2018%2F03%2F12%2F%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[并发编程概念 并发同时做多件事情。 并发编程有：多线程编程、异步编程、响应式编程。并行处理是多线程的一种。 多线程编程并发的一种形式，它采用多个线程来执行程序。并行处理是多线程的一种。 并行处理：把正在执行的大量的任务分割成小块，分配给多个同时运行的线程。 异步编程并发的一种形式，它采用 future 模式或回调（callback）机制，以避免产生不必要的线程。 异步编程的核心理念是异步操作：启动了的操作将会在一段时间后完成。这个操作正在执行时，不会阻塞原来的线程。启动了这个操作的线程，可以继续执行其他任务。当操作完成时，会通知它的 future，或者调用回调函数，以便让程序知道操作已经结束。 现代的异步 .NET 程序使用两个关键字： async 和 await 。 async 关键字加在方法声明上，它的主要目的是使方法内的 await 关键字生效（为了保持向后兼容，同时引入了这两个关键字）。如果 async 方法有返回值，应返回 Task&lt;T&gt; ；如果没有返回值，应返回 Task 。 这些task 类型相当于 future，用来在异步方法结束时通知主程序。 await 关键字是针对 Task 的，确切的说是针对所有遵循特定模式的 awaitable 类型。 注意： 不要用 void 作为 async 方法的返回类型！ async 方法可以返回 void ，但是这仅限于编写事件处理程序。一个普通的 async 方法如果没有返回值，要返回Task ，而不是 void 。 1234567891011121314151617/// &lt;summary&gt;/// async事件，返回值为void,特例/// &lt;/summary&gt;private async void button1_Click(object sender, EventArgs e)&#123; await DoSomethingAsync(); //等待异步执行完成再执行后面的语句，但界面不会阻塞 label1.Text = "Done!";&#125;/// &lt;summary&gt;/// 普通事件，返回值为void/// &lt;/summary&gt;private void button1_Click(object sender, EventArgs e)&#123; DoSomethingAsync(); //直接返回，先执行后面语句！ lablabel1.Text = "Done!";&#125; 注意：关于异步方法，还有一条重要的准则：你一旦在代码中使用了异步，最好一直使用。调用异步方法时，应该（在调用结束时）用 await 等待它返回的 task 对象。一定要避免使用 Task.Wait 或 Task&lt;T&gt;.Result 方法，因为它们会导致死锁。参考一下下面这个方法： 123456789101112131415async Task WaitAsync()&#123; // 这里 awati 会捕获当前上下文…… await Task.Delay(TimeSpan.FromSeconds(1)); //.ConfigureAwait(false);加上这个就没问题 // ……这里会试图用上面捕获的上下文继续执行&#125;void Deadlock()&#123; // 开始延迟 Task task = WaitAsync(); // 同步程序块，正在等待异步方法完成 task.Wait();&#125; ConfigureAwait 的说明是：试图继续回夺取的原始上下文，则为 true；否则为 false。 响应式编程一种声明式的编程模式，程序在该模式中对事件做出响应。 响应式编程与异步编程非常类似，不过它是基于异步事件（asynchronous event）的，而不是异步操作（asynchronous operation）。异步事件可以没有一个实际的“开始”，可以在任何时间发生，并且可以发生多次，例如用户输入。 参考 ASP.NET sync over async（异步中同步，什么鬼？） async &amp; await 的前世今生 异步编程 In .NET]]></content>
      <categories>
        <category>C#基础</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#值类型与引用类型]]></title>
    <url>%2F2018%2F03%2F08%2F%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[C#值类型与引用类型 C#类型C#类型中分两种：值类型，引用类型。所有值类型 都隐式的继承自 System.ValueType ，所有类型 都继承自 System.ObjectType 。 栈与堆堆存储的是为引用类型的实例分配的内存栈上存储的是变量。变量分值类型变量，和引用类型变量。引用类型变量存储了对实例的引用。当声明一个值类型变量的时候，变量本身包含了值类型的全部字段。 1. 值类型值类型包括结构和枚举，还有一种特殊值类型（简单类型）, 比如int，byte等。 值类型需要注意以下几点： - 声明变量其实并为入栈。赋值=入栈，取值=出栈 - 调用结构上的方法前，需要对其所有的字段进行赋值 - 结构 SampleStruct, new SampleStruct() 仅仅隐式的给结构上的所有字段赋值 2. 引用类型引用类型包括类，接口，委托等。 对象判等 引用类型string 类型的判等比较特殊。并非比较引用地址，而是比较值。 对象复制 浅度复制 对象的成员有可能是值类型，有可能是引用类型。当对对象进行一个浅度复制的时候，对于值类型成员，会复制其本身（值类型变量本身包含了所有数据，复制时进行按位复制）；对于引用类型成 员（注意它实际只是一个对象引用，指向了堆上的对象实例），仅仅复制引用，而不在堆上重新创建对象。因此，浅度复制结果就是：新对象的引用成员和复制对象的引用成员指向了同一个对象。 深度复制 不可变类型 string 类型是一个特殊的引用类型——不可变类型。每次值改变都会创建一个新的对象实例，StringBuilder则不会。在string类型作为方法参数的时候，需要特别注意。]]></content>
      <categories>
        <category>C#基础</category>
        <category>类型基础</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker环境搭建]]></title>
    <url>%2F2018%2F02%2F03%2FDocker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[在Ubuntu16.04系统下安装Docker 在Ubuntu16.04系统下安装Docker使用镜像仓库进行安装设置镜像仓库 更新 apt 软件包索引： 12&gt; $ sudo apt-get update&gt; 安装软件包，以允许 apt 通过 HTTPS 使用镜像仓库： 123456&gt; $ sudo apt-get install \&gt; apt-transport-https \&gt; ca-certificates \&gt; curl \&gt; software-properties-common&gt; 添加 Docker 的官方 GPG 密钥： 12&gt; $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -&gt; 验证密钥指纹是否为 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88。 1234567&gt; $ sudo apt-key fingerprint 0EBFCD88&gt;&gt; pub 4096R/0EBFCD88 2017-02-22&gt; Key fingerprint = 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88&gt; uid Docker Release (CE deb) &lt;docker@docker.com&gt;&gt; sub 4096R/F273FCD8 2017-02-22&gt; 使用下列命令设置 stable 镜像仓库。您始终需要使用 stable 镜像仓库，即使您还需要通过 edge 或 testing 镜像仓库安装构建也是如此。如需添加 edge 或 testing 镜像仓库，请在以下命令中的词 stable 之后添加词 edge 和/或 testing。 注：下面的 lsb_release -cs 子命令用于返回您的 Ubuntu 分发版，例如 xenial。 有时，在 Linux Mint 等分发版中，您可能必须将 $(lsb_release -cs) 更改为您的父代 Ubuntu 分发版。例 如：如果您使用的是 Linux Mint Rafaela，您可以使用 trusty。 amd64： 12345&gt; $ sudo add-apt-repository \&gt; "deb [arch=amd64] https://download.docker.com/linux/ubuntu \&gt; $(lsb_release -cs) \&gt; stable"&gt; 注：从 Docker 17.06 开始，还会将 stable 版本推送到 edge 和 testing 镜像仓库。了解 stable 和 edge 渠道。 安装 DOCKER CE 更新 apt 软件包索引。 12&gt; $ sudo apt-get update&gt; 安装最新版本的 Docker CE，或者转至下一步以安装特定版本。将替换任何现有的 Docker 安装版本。 12&gt; $ sudo apt-get install docker-ce&gt; 警告： 如果您启用了多个 Docker 镜像仓库，进行安装 或者更新而不在 apt-get install 或 apt-get update 命令中指定版本将始终安装可用的最高版本， 这可能无法满足您的稳定性需求。 在生产系统中，您应该安装特定版本的 Docker CE，而不是始终使用最新版本。此输出将被截断。列出可用版本。 123&gt; $ apt-cache madison docker-ce&gt; docker-ce | 17.06.0~ce-0~ubuntu-xenial | https://download.docker.com/linux/ubuntu xenial/stable amd64 Packages&gt; 此列表的内容取决于启用了哪些镜像仓库，并且将特定于 您的 Ubuntu 版本（在本示例中，由版本中的 xenial 后缀 表示）。选择一个特定版本进行安装。第二列为版本字符 串。第三列为镜像仓库名称，它表示软件包来自哪个镜像仓 库并按扩展其稳定性级别列出。如需安装特定版本，请将版 本字符串附加到软件包名称，并使用等号 (=) 分隔它们： 12&gt; $ sudo apt-get install docker-ce=&lt;VERSION&gt;&gt; Docker 守护进程将自动启动。 验证是否正确安装了 Docker CE，方法是运行 hello-world 镜像。 12&gt; $ sudo docker run hello-world&gt; 此命令将下载一个测试镜像并在容器中运行它。容器运行 时，它将输出一条参考消息并退出。 Docker CE 已安装并且正在运行。您需要使用 sudo 运行 Docker 命令。继续执行 Linux 安装后步骤以允许非特权用户运行 Docker 命令，以及了解其他可选配置步骤。 参考链接 官方中文安装 官方英文安装]]></content>
      <categories>
        <category>docker</category>
        <category>linux</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker安装MySql]]></title>
    <url>%2F2018%2F02%2F03%2FDocker%E5%AE%89%E8%A3%85MySql%2F</url>
    <content type="text"><![CDATA[mysql on docker Docker安装MySql安装 mysql 镜像 拉取mysql 镜像： 1docker pull mysql/mysql-server 安装： 1docker run -d -p 3306:3306 --name [mysql 容器名称] mysql/mysql-server 查看日志： 123docker logs [mysql 容器名称]docker logs [mysql 容器名称] 2&gt;&amp;1docker logs [mysql 容器名称] 2&gt;&amp;1 | grep GENERATED （查看随机密码） 监视： 1docker inspect [mysql 容器名称] mysql镜像 进入mysql bash环境命令： 1docker exec -it [mysql 容器名称] bash mysql登录命令： 1mysql -hIP -uUSENME -pPWD -PPORT DBNAME -e "sql" 1mysql -uroot -p 通过 docker logs [mysql 容器名称] 查看生成的root账户随机密码 mysql 设置： 使用mysql系统数据库 1use mysql 重置root账户密码 1SET PASSWORD FOR 'root'@'localhost' = PASSWORD('pwd123456'); 出现错误，数据库连接失败： 1Host '192.168.0.106' is not allowed to connect to this MySQL server 远程连接失败是因为root用户host限制为localhost： 12345678910mysql&gt; select user,host from user;+---------------+-----------+| user | host |+---------------+-----------+| healthchecker | localhost || mysql.session | localhost || mysql.sys | localhost || root | localhost |+---------------+-----------+4 rows in set (0.00 sec) 创建新用户 123456mysql&gt; CREATE USER 'or'@'localhost' IDENTIFIED BY 'pwd123456';mysql&gt; GRANT ALL PRIVILEGES ON *.* TO 'or'@'localhost' -&gt; WITH GRANT OPTION;mysql&gt; CREATE USER 'or'@'%' IDENTIFIED BY 'pwd123456';mysql&gt; GRANT ALL PRIVILEGES ON *.* TO 'or'@'%' -&gt; WITH GRANT OPTION; 12345678910111213mysql&gt; select user,host from user -&gt; ;+---------------+-----------+| user | host |+---------------+-----------+| or | % || healthchecker | localhost || mysql.session | localhost || mysql.sys | localhost || or | localhost || root | localhost |+---------------+-----------+6 rows in set (0.00 sec) 字符集： 1234567891011121314mysql&gt; show variables like '%char%';+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | latin1 || character_set_connection | latin1 || character_set_database | latin1 || character_set_filesystem | binary || character_set_results | latin1 || character_set_server | latin1 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+8 rows in set (0.01 sec) 设置mysql默认字符集为utf8: 修改MYSQL 默认字符集： 12cd /etcvim my.cnf 添加到my.cnf 1234567891011[mysqld]character-set-server=utf8[client]default-character-set=utf8[mysql]default-character-set=utf8 1234567891011121314mysql&gt; show variables like '%char%';+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | latin1 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | latin1 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+8 rows in set (0.00 sec) 环境变量 mysql 在Docker上配置官方文档 e.g. 1sudo docker run -p 3305:3306 -d -e MYSQL_USER="or" -e MYSQL_PASSWORD="pwd123456" -e MYSQL_ROOT_PASSWORD="rootpwd" --name mysql02 mysql/mysql-server --character-set-server=utf8 --collation-server=utf8_general_ci 挂载到宿主机（Host Volume） 建立host上的文件夹： 12345mkdir -p docker/mysqlcd docker/mysqlmkdir config data 在config 文件夹下添加文件一个my.cnf 1vi my.cnf 添加以下配置，后期改动重启mysql镜像即可 1234567[mysqld]user=mysqlcharacter-set-server=utf8 [client]default-character-set=utf8 [mysql]default-character-set=utf8 使用volumn挂载外部文件 1sudo docker run -d -p 3304:3306 -e MYSQL_ROOT_PASSWORD=pwd123456 -e MYSQL_ROOT_HOST=% --name mysql03 -v=/docker/mysql/config/my.cnf:/etc/my.cnf -v=/docker/mysql/data:/var/lib/mysql mysql/mysql-server 删除镜像，同时注意删除data文件夹，否则会有密码缓存 TODO mysql 日志 my.cnf 里面添加配置即可 123456789101112[mysqld]user=mysqlcharacter-set-server=utf8# log_bin=D:\mysql-5.7.15-winx64\log\mysql-bin.log# log_error=D:\mysql-5.7.15-winx64\log\mysql.err# long_query_time=1# slow_query_log=ON# slow_query_log_file=D:\mysql-5.7.15-winx64\log\mysql-slow.loggeneral_log=ONgeneral_log_file=/var/lib/mysql/mysql03.logslow_query_log = onslow-query-log-file=/var/lib/mysql/mysql03-slow.log]]></content>
      <categories>
        <category>docker</category>
        <category>linux</category>
        <category>mysql</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker基础概念]]></title>
    <url>%2F2018%2F02%2F02%2FDocker%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[Docker基础概念记录 镜像、容器、仓库镜像容器仓库三者关系 镜像从仓库里拉取到本地，成为本地镜像本地镜像运行后是容器，运行前还是镜像 命令 命令 说明 docker –version 查看当前的版本 docker ps 查看当前正在运行的容器 docker images 查看本地所有镜像 docker run 运行一个容器 docker pull 用来拉取一个容器到本地 相关文档 官方中文文档 Docker从入门到实践 Docker Hub]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs环境配置]]></title>
    <url>%2F2017%2F07%2F19%2FNodejs%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[使用 nvm 统一管理 Nodejs 版本 下载安装 nvm-windows （手动安装）直接在Release页面下载，下载手动安装版本nvm-noinstall.zip：https://github.com/coreybutler/nvm-windows/releases 在要安装的文件夹下，右键-在此处打开命令行，在命令行中执行：git clone https://github.com/coreybutler/nvm-windows.git 以上二选一，以下介绍均基于第一种 配置nvmw配置 更改系统环境变量，有两个是新增：NVM_HOME,NVM_SYMLINK，一个是修改：Path NVM_HOME：解压安装包的路径，如果是自动安装版本，默认是：C:\Users\&lt;username&gt;\AppData\Roaming\nvm NVM_SYMLINK：这个路径必须不存在，nvmw会自动生成，此路径用于辨认当前使用的是哪个版本的Nodejs Path：在这个系统环境变量后边加上%NVM_HOME%;%NVM_SYMLINK%,注意原Path变量要;结尾，没有便加上 把上面这些同时应用于用户变量，否则你将需要重启电脑 在安装目录下添加settings.txt，内容如下： root: NVM_HOME的内容 path: NVM_SYMLINK的内容 proxy: 默认设置为 “none”。如果需要配置，可以通过命令行 arch: 32/64，操作系统是32位还是64位 123456root: C:\Users\Corey\AppData\Roaming\nvmpath: C:\Program Files\nodejsarch: 64proxy: nonenode_mirror: https://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/ nvmw安装成功测试 如果没有将系统环境变量配置应用于用户环境变量，需要重启电脑 在命令行输入nvm，回车，出现帮助信息，那么安装成功了 安装Nodejs nvm install latest nvm use [version] 输入node -v ，显示版本即成功]]></content>
      <categories>
        <category>工具</category>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git操作]]></title>
    <url>%2F2017%2F05%2F17%2FGit%E6%93%8D%E4%BD%9C%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Git操作基础概念 Git操作提交（commit）获取（fetch）拉取（pull）拉取（pull）= 获取（fetch）+ 合并（merge） 合并（merge）合并示意图 变基（rebase） 变基遵守法则：不要对在你的仓库外有副本的分支执行变基推送（push）同步同步= 拉取（pull） + 推送（push） 常用命令 从命令行创建一个新的仓库 123456touch README.mdgit initgit add README.mdgit commit -m "first commit"git remote add origin http://192.168.0.100:3000/Faror/Test.gitgit push -u origin master 从命令行推送已经创建的仓库 12git remote add origin http://192.168.0.100:3000/Faror/Test.gitgit push -u origin master 参考Pro Git]]></content>
      <categories>
        <category>git</category>
        <category>工具</category>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH]]></title>
    <url>%2F2017%2F05%2F17%2FSSH%2F</url>
    <content type="text"><![CDATA[SSH 原理 SSH1. SSH原理 中间人攻击 SSH之所以能够保证安全，原因在于它采用了公钥加密。整个过程是这样的： 远程主机收到用户的登录请求，把自己的公钥发给用户。 用户使用这个公钥，将登录密码加密后，发送回来。 远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。https://github.com/O-R/Blog.git 这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。 可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的”中间人攻击”（Man-in-the-middle attack）。 公钥登录 公钥登录的步骤： 客户端发起请求，请求内容包括公钥等 远程主机接到请求，寻找到对应公钥，并用公钥将质询（一段随机字符串吧）加密后发送给客户端 客户端使用私钥+私钥对应的口令（passphrase，如果有）对质询进行解密，并将解密后的质询以及当前会话ID进行MD5加密后，发送给远程主机 远程主机使用同样方法加密质询及当前会话ID，并进行比对，匹配上了则登录成功。 此为远程主机公钥加密，客户端私钥解密的说法，也有私加公解的说法，感觉差不多。。 2. SSH登录（RSA） 生成密钥对 1ssh-keygen -t rsa -b 2048 语法： 123456ssh-keygen \ -t rsa \ -b 2048 \ -C "azureuser@myserver" \ -f ~/.ssh/id_rsa \ -N mypassword 命令解释：ssh-keygen = 用于创建密钥的程序-t rsa = 要创建的 RSA 格式密钥类型 [wikipedia]parens 结尾 -b 2048 = 密钥的位数-C &quot;azureuser@myserver&quot; = 追加到公钥文件末尾以便于识别的注释。 通常以电子邮件作为注释，但也可以使用任何最适合基础结构的事物。 123456789101112131415161718192021ssh-keygen -t rsa -b 2048 -C "azureuser@myserver"Generating public/private rsa key pair.Enter file in which to save the key (/home/azureuser/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /home/azureuser/.ssh/id_rsa.Your public key has been saved in /home/azureuser/.ssh/id_rsa.pub.The key fingerprint is:14:a3:cb:3e:78:ad:25:cc:55:e9:0c:08:e5:d1:a9:08 azureuser@myserverThe keys randomart image is:+--[ RSA 2048]----+| o o. . || E. = .o || ..o... || . o.... || o S = || . + O || + = = || o + || . |+-----------------+ 使用 SSH 密钥对 公钥默认存储在 ~/.ssh/id_rsa.pub 中，除非你在创建该公钥时更改了位置。如果不熟悉 SSH 公钥，则可通过运行 cat 来查看公钥（如下所示），注意需将 ~/.ssh/id_rsa.pub 替换为你自己的公钥文件位置： 1cat ~/.ssh/id_rsa.pub 通过 SSH 使用 VM 的 IP 地址或 DNS 名称连接到 VM（记住将下面的 azureuser 和 myvm.westus.cloudapp.azure.com 替换为管理员用户名和完全限定域名或 IP 地址）： 1ssh azureuser@myvm.westus.cloudapp.azure.com 如果你是第一次登录远程主机，系统会出现下面的提示： 1234$ ssh user@hostThe authenticity of host 'host (12.18.429.21)' can't be established.RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.Are you sure you want to continue connecting (yes/no)? 这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？ 所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。 很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。 假定经过风险衡量以后，用户决定接受这个远程主机的公钥。 1 Are you sure you want to continue connecting (yes/no)? yes 系统会出现一句提示，表示host主机已经得到认可。 1 Warning: Permanently added 'host,12.18.429.21' (RSA) to the list of known hosts. 然后，会要求输入密码。 1 Password: (enter password) 如果密码正确，就可以登录了。当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。 3. 参考链接 如何创建和使用适用于 Azure 中 Linux VM 的 SSH 公钥和私钥对 详细演练了如何为 Azure 中的 Linux VM 创建 SSH 密钥对和其他证书 SSH原理与运用（一）：远程登录]]></content>
      <categories>
        <category>linux</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu_登录]]></title>
    <url>%2F2017%2F05%2F17%2Fubuntu_%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[ubuntu 使用 ssh 远程登录 一、 登录1. 生成SSH密钥生成命令：1ssh-keygen -t rsa -b 2048 查看密钥(位于C:\Users\当前windows用户\AppData\Local\lxss\home\ssh用户\.ssh)1cat ~/.ssh/id_rsa.pub 使用 ssh-agent 来存储私钥密码(这种方法好像并没什么卵用)为了避免在每次 SSH 登录时键入私钥文件密码，可以使用 ssh-agent 来缓存私钥文件密码。 如果使用 Mac，OSX Keychain 在用户调用 ssh-agent时会安全存储私钥密码。 验证并使用 ssh-agent 和 ssh-add 将密钥文件的情况通知给 SSH 系统，使密码不需以交互方式使用。 1eval "$(ssh-agent -s)" 现在，使用命令 ssh-add 将私钥添加到 ssh-agent。 1ssh-add ~/.ssh/id_rsa 私钥密码现在存储在 ssh-agent 中。 使用 ssh-copy-id 将密钥复制到现有 VM如果已创建 VM，则可使用以下命令将新的 SSH 公钥安装到 Linux VM： 1ssh-copy-id -i ~/.ssh/id_rsa.pub ahmet@myserver 注意：遇到无法连接22端口，可能未安装openssh-server 安装命令： 12sudo apt-get install openssh-serversudo /etc/init.d/ssh restart（重新启动ssh服务） 创建并配置 SSH 配置文件建议的最佳做法是，创建并配置 ~/.ssh/config 文件，以便加速登录和优化 SSH 客户端行为。以下示例显示了标准配置。 创建文件 1touch ~/.ssh/config 编辑文件以添加新的 SSH 配置： 1vim ~/.ssh/config 示例 ~/.ssh/config 文件： 123456789101112131415# Azure KeysHost fedora22 Hostname 102.160.203.241 User ahmet# ./Azure Keys# Default SettingsHost * PubkeyAuthentication=yes IdentitiesOnly=yes ServerAliveInterval=60 ServerAliveCountMax=30 ControlMaster auto ControlPath ~/.ssh/SSHConnections/ssh-%r@%h:%p ControlPersist 4h IdentityFile ~/.ssh/id_rsa 此 SSH 配置可以指定每个服务器的部分，以便每个服务器使用自己的专用密钥对。 默认设置 (Host *) 适用于不匹配配置文件中更高级别特定主机的任何主机。配置文件解释 Host = 在终端上调用的主机的名称。 ssh fedora22 告知 SSH 使用标记为 Host fedora22 的设置块中的值。注意：主机可以是符合用途的任何标签，并不代表任何服务器的实际主机名。 Hostname 102.160.203.241 = 所访问的服务器的 IP 地址或 DNS 名称。 User ahmet = 登录到服务器时要使用的远程用户帐户。 PubKeyAuthentication yes = 告知 SSH 要使用 SSH 密钥来登录。 IdentityFile /home/ahmet/.ssh/id_id_rsa = 要用于身份验证的 SSH 私钥和对应的公钥。 在不提供密码的情况下使用 SSH 连接到 Linux获得 SSH 密钥对并配置 SSH 配置文件后，便可以快速安全地登录到 Linux VM 了。 首次使用 SSH 密钥登录到服务器时，命令会提示用户输入该密钥文件的通行短语。 1ssh fedora22 命令解释 执行 ssh fedora22 后，SSH 先从 Host fedora22 块中找到并加载所有设置，并从最后一个块 (Host *) 中加载所有剩余设置。 2、远程桌面登录使用 apt 安装轻型 xfce4 桌面环境12sudo apt-get updatesudo apt-get install xfce4 安装和配置远程桌面服务器安装桌面环境后，请配置远程桌面服务来侦听传入连接。 xrdp 是大多数 Linux 分发版中提供的开源远程桌面协议 (RDP) 服务器，可与 xfce 完美配合。 在 Ubuntu VM 上安装 xrdp，如下所示： 1sudo apt-get install xrdp 告诉 xrdp 在启动会话时要使用的桌面环境。 配置 xrdp 以使用 xfce 作为桌面环境，如下所示： 1echo xfce4-session &gt;~/.xsession 重新启动 xrdp 服务使更改生效，如下所示： 1sudo service xrdp restart 设置本地用户帐户密码 如果在创建 VM 时已为用户帐户创建密码，请跳过此步骤。 如果仅使用 SSH 密钥身份验证，并且未设置本地帐户密码，请在使用 xrdp 之前指定密码以登录到 VM。 xrdp 无法接受使用 SSH 密钥进行身份验证。 以下示例为用户帐户 azureuser 指定密码： 1sudo passwd azureuser 备注 :指定密码不会将 SSHD 配置更新为允许密码登录（如果当前不允许）。 为远程桌面流量创建网络安全组规则若要允许远程桌面流量到达 Linux VM，需要创建网络安全组规则以允许端口 3389 上的 TCP 访问 VM。至此，就可以用windows远程桌面登录了]]></content>
      <categories>
        <category>linux</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 14.04下安装和配置ShadowSocks服务器]]></title>
    <url>%2F2017%2F05%2F17%2Fss%2F</url>
    <content type="text"><![CDATA[Ubuntu 14.04下安装和配置ShadowSocks服务器 ShadowSocks服务器的安装、配置、运行、停止 Ubuntu 14.04下安装和配置ShadowSocks服务器安装ShadowSocks服务器在Ubuntu下安装ShadowSocks服务器端其实很简单，只需要键入下面几条命令就可以了： 1234sudo apt-get update sudo apt-get install python-gevent python-pip sudo pip install shadowsocks apt-get install python-m2crypto 配置ShadowSocks服务器ShadowSocks服务器的配置文件可以放到任何你想放的位置，起任何的名字。出于习惯，可以将其放在/etc目录下，名字为shadowsocks.json： 1vim /etc/shadowsocks.json 在编辑器里面修改文件内容为： 12345678&#123; "server":"serverip", "server_port":8388, "local_port":1080, "password":"Your Password", "timeout":600, "method":"aes-256-cfb" &#125; 你可以更改“server_port”字段，修改ShadowSocks服务器的端口。还有“method”字段指定的是加密算法，ShadowSocks服务器支持多种加密算法（aes-256-cfb，aes-192-cfb，aes-128-cfb，rc4-md5，des-cfb等等），可以根据需要自己配置。 运行ShadowSocks服务器注意ShadowSocks服务器要在root用户下运行，所以一开始请切换用户。然后只需要输入下面的命令就可以了： 1ssserver -c /etc/shadowsocks.json -d start -c参数用来指定ShadowSocks服务器端配置文件的路径，只要设置成前一步修改的配置文件的路径名就好了。 停止ShadowSocks服务器同样要在root用户下，执行下面的命令即可： 1ssserver -c /etc/shadowsocks.json -d stop SS客户端下载地址 github地址 其他下载地址 谷歌插件 SwitchyOmega]]></content>
      <categories>
        <category>linux</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>ss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu常用命令]]></title>
    <url>%2F2017%2F05%2F17%2Fubuntu%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常用命令apt用户/用户组 查看所有用户 cat /etc/passwd 查看所有用户组 cat /etc/group1.添加用户 sudo adduser or 将用户添加到 sudoers root用户下使用 visudosudo vim /etc/sudoers 修改文件如下： # User privilege specificationroot ALL=(ALL) ALLor ALL=(ALL) ALL 进程、端口占用 netstat -tln：查看端口占用 lsof -i:port：查看端口进程信息 查看所有服务端口 cat /etc/services | less 防火墙 ufw文件权限 chmod列举文件 ls移动/复制/剪切 mv删除 rm sudo apt-get purge –auto-remove packagename 解压缩 rar代理测试1234567891011# 访问各大网站，若均有网页源码输出则配置成功curl -4skL https://www.baidu.comcurl -4skL https://www.google.comcurl -4skL https://www.google.com.hkcurl -4skL https://www.google.co.jpcurl -4skL https://www.youtube.comcurl -4skL https://www.facebook.comcurl -4skL https://www.wikipedia.org# 获取当前 IP 地址，应该显示本机 IPcurl -4skL http://ip.chinaz.com/getip.aspx]]></content>
      <categories>
        <category>linux</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu_系统常规配置]]></title>
    <url>%2F2017%2F05%2F17%2Fubuntu_%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[ubuntu 文件传输、语言环境、远程桌面安装 系统常规配置文件传输安装 lrzsz 1apt install lrzsz bash命令行输入 rz -e ：打开当前终端文件进行传输 sz -e 文件在远程机器上路径:打开当前终端选择下载文件位置 语言环境bash终端 查看当前系统的语言环境 locale 查看当前系统已安装的语言 locale -a 切换（并自动安装）对应选择的默认语言 sudo dpkg-reconfigure locales 安装缺少的语言 sudo locale-gen zh_CN.UTF-8 编辑配置文件 1234ubuntu@VM-14-193-ubuntu:~$ vim ~/.profile# 添加下面内容export LANG="zh_CN.UTF-8"export LC_ALL="zh_CN.UTF-8" 远程桌面安装文泉驿字体 apt install wqy* -y xfce4 解压缩工具安装命令: 1apt install thunar-archive-plugin -y 文本编辑器安装命令: 1apt install gedit -y 或 1apt install mousepad -y xfce4 软件包列表其中依赖必需的包在你执行apt-get iinstall xfce4的时候就已经完成安装了 除了Lib库文件、主要有以下的包 1234567891011121314151617gtk2-engines-xfce GTK+-2.0 对于Xfce的主题显示支持 orage Xfce 桌面环境的日历和时间管理thunar Xfce 的文件管理器 xfce4-appfinder Xfce中运行命令和应用程序查找、就是应用程序菜单第一个项目xfce4-mixer Xfce中的混音器、简单说就是音量外放和话题之类的控制xfce4-panel Xfce中的面板管理器xfce4-session Xfce中的会话管理器 xfce4-settings Xfce中的设置（是指图形界面的设置、就是打开菜单能看到的那个设置）xfce4-utils Xfce中各个方面的工具xfconf Xfce设置管理器中的实用工具xfdesktop4 xfce的桌面背景、图标、还有菜单管理都由这个提供xfwm4 Xfce中的视窗管理器desktop-base Debian 桌面环境的公共基础tango-icon-theme Tango 主题图标 thunar-volman Thunar 文件管理器的音量控制扩展 xfce4-notifyd 可视化的通知守护进程 以上这些软件包是你在安装Xfce4的时候因为依赖安装的包、其中最后的三个在Debian软件仓库里面是提示推荐的包。 下面说下Xfce中可以用来扩充功能的包、就是这些包在最小化配置的时候不会默认安装好、但是没有它们有些功能不能使用 xfprint4 Xfce4 桌面环境下使用的打印机管理器。 Xfce4-goodies是由下面的包填充的、也就是说、你安装 xfce4-goodies其实是安装的下面这些软件包 12345678910111213141516171819202122232425262728293031323334353637383940414243444546xfce4-artwork Xfce桌面环境美化的扩展包、会安装一些图标、主题、壁纸xfce4-battery-plugin 电池电量的显示器xfce4-clipman-plugin 剪切板历史记录查看xfce4-cpufreq-plugin 设置CPU频率xfce4-cpugraph-plugin CPU利用率查看xfce4-datetime-plugin 日期和时间插件xfce4-diskperf-plugin 磁盘情况监控xfce4-fsguard-plugin 文件系统监控xfce4-genmon-plugin 显示一些命令提示xfce4-mailwatch-plugin 邮件通知xfce4-mount-plugin 挂载管理xfce4-netload-plugin 网络xfce4-notes-plugin 笔记xfce4-places-plugin 快速管理收藏夹、最近使用、可移除驱动器xfce4-quicklaunchers 快速启动xfce4-sensors-plugin 传感器、可以查看硬件温度xfce4-smartbookmark-plugin 收藏夹xfce4-systemload-plugin 系统加载项查看xfce4-timer-plugin 计时器xfce4-verve-plugin 提供命令记忆功能xfce4-wavelan-plugin 无线网运行情况xfce4-weather-plugin 天气预报xfce4-xkb-plugin 键盘配置thunar-archive-plugin 压缩文件的解压插件thunar-media-tags-plugin 提供媒体文件标签功能mousepad 一个简单的文本编辑器ristretto 图像查看器xfburn DVD刻录软件xfce4-dict 词典xfce4-notifyd 通知xfce4-screenshooter 截图xfce4-taskmanager 任务管理器xfce4-terminal 终端xfce4-cellmodem-plugin 调制解调器xfce4-linelight-plugin 一个搜索程序xfce4-messenger-plugin DBus消息通知xfce4-minicmd-plugin 额外的终端软件xfce4-mpc-plugin, xfmpc Music Player Daemon播放器守护程序，管理播放列表和音乐数据库xfce4-radio-plugin 收音机插件xfce4-xfapplet-plugin 提供GNOME环境中的一些小应用程序支持xfswitch-plugin 用户快速切换xfce4-hdaps ThinkPads的HDAPS插件thunar-thumbnailers 为文件管理器提供图像预览功能gigolo GIO/GVfs虚拟文件系统的远程管理前端parole 视频播放器xfce4-power-manager 电源管理 以上软件包可以单独安装的、所以看你需要添加即可]]></content>
      <categories>
        <category>linux</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu修改时区并同步时间]]></title>
    <url>%2F2017%2F05%2F17%2F%E4%BF%AE%E6%94%B9%E6%97%B6%E5%8C%BA%E5%B9%B6%E5%90%8C%E6%AD%A5%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[ubuntu修改时区并同步时间 修改时区并同步时间修改时区 查看时区 date -RTue, 12 Dec 2017 07:36:14 +0000 选择时区 sudo tzselect 报错（ubuntu 14.04的一个bug）：/usr/bin/tzselect: line 171: /home/or/iso3166.tab: No such file or directory/usr/bin/tzselect: time zone files are not set up correctly 解决方法sudo vim /usr/bin/tzselect将 ${TZDIR=pwd} 修改为 ${TZDIR=/usr/share/zoneinfo} 选择区域：亚洲 12345678910111213141516&gt; Please identify a location so that time zone rules can be set correctly.&gt; Please select a continent, ocean, "coord", or "TZ".&gt; 1) Africa&gt; 2) Americas&gt; 3) Antarctica&gt; 4) Arctic Ocean&gt; 5) Asia&gt; 6) Atlantic Ocean&gt; 7) Australia&gt; 8) Europe&gt; 9) Indian Ocean&gt; 10) Pacific Ocean&gt; 11) coord - I want to use geographical coordinates.&gt; 12) TZ - I want to specify the time zone using the Posix TZ format.&gt; #? 5&gt; 选择中国 1234567891011121314151617181920&gt; Please select a country whose clocks agree with yours.&gt; 1) Afghanistan 18) Israel 35) Palestine&gt; 2) Armenia 19) Japan 36) Philippines&gt; 3) Azerbaijan 20) Jordan 37) Qatar&gt; 4) Bahrain 21) Kazakhstan 38) Russia&gt; 5) Bangladesh 22) Korea (North) 39) Saudi Arabia&gt; 6) Bhutan 23) Korea (South) 40) Singapore&gt; 7) Brunei 24) Kuwait 41) Sri Lanka&gt; 8) Cambodia 25) Kyrgyzstan 42) Syria&gt; 9) China 26) Laos 43) Taiwan&gt; 10) Cyprus 27) Lebanon 44) Tajikistan&gt; 11) East Timor 28) Macau 45) Thailand&gt; 12) Georgia 29) Malaysia 46) Turkmenistan&gt; 13) Hong Kong 30) Mongolia 47) United Arab Emirates&gt; 14) India 31) Myanmar (Burma) 48) Uzbekistan&gt; 15) Indonesia 32) Nepal 49) Vietnam&gt; 16) Iran 33) Oman 50) Yemen&gt; 17) Iraq 34) Pakistan&gt; #? 9&gt; 选择中国东部 12345678&gt; Please select one of the following time zone regions.&gt; 1) east China - Beijing, Guangdong, Shanghai, etc.&gt; 2) Heilongjiang (except Mohe), Jilin&gt; 3) central China - Sichuan, Yunnan, Guangxi, Shaanxi, Guizhou, etc.&gt; 4) most of Tibet &amp; Xinjiang&gt; 5) west Tibet &amp; Xinjiang&gt; #? 1&gt; 确认信息 12345678910111213&gt; The following information has been given:&gt; &gt; China&gt; east China - Beijing, Guangdong, Shanghai, etc.&gt; &gt; Therefore TZ='Asia/Shanghai' will be used.&gt; Local time is now: Tue Dec 12 15:53:53 CST 2017.&gt; Universal Time is now: Tue Dec 12 07:53:53 UTC 2017.&gt; Is the above information OK?&gt; 1) Yes&gt; 2) No&gt; #? 1&gt; 设置成功 12345678&gt; You can make this change permanent for yourself by appending the line&gt; TZ='Asia/Shanghai'; export TZ&gt; to the file '.profile' in your home directory; then log out and log in again.&gt; &gt; Here is that TZ value again, this time on standard output so that you&gt; can use the /usr/bin/tzselect command in shell scripts:&gt; Asia/Shanghai&gt; 复制文件到/etc目录下 sudo cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 设置系统时间与网络时间同步 安装ntpdate工具 sudo apt-get install ntpdate 设置系统时间与网络时间同步 sudo ntpdate cn.pool.ntp.org 将系统时间写入硬件时间 sudo hwclock –systohc //非常重要，如果没有这一步的话，后面时间还是不准]]></content>
      <categories>
        <category>linux</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在VM中设置Ubuntu静态IP]]></title>
    <url>%2F2017%2F05%2F17%2F%E5%9C%A8VM%E4%B8%AD%E8%AE%BE%E7%BD%AEUbuntu%E9%9D%99%E6%80%81IP%2F</url>
    <content type="text"><![CDATA[在VM中设置Ubuntu静态IP 在VM中设置Ubuntu静态IPNAT模式 VM中打开 编辑 -&gt; 虚拟机网络编辑器 获取到 可用IP范围、网关和子网掩码 通过命令配置固定IP 如下图： 可以获取到 可用IP范围、网关和子网掩码 可用IP范围：192.168.175.128~192.168.175.254 网关：255.255.255.0 子网掩码：192.168.175.2 打开配置文件 vim /etc/network/interfaces，修改配置： 123456789101112auto loiface lo inet loopback# Assgin static IP by eric on 26-SEP-2012auto ens33iface ens33 inet staticaddress 192.168.175.139 #change to your static IPnetmask 255.255.255.0 #change to your netmaskgateway 192.168.175.2 #change to your getway#We must specify dns-nameserver here#in order to get internet access from hostdns-nameservers 192.168.175.2 重启ubuntu网卡：sudo /etc/init.d/networking restart 重启系统：reboot 测试外网：ping www.baidu.com]]></content>
      <categories>
        <category>linux</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>vm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu 配置代发邮箱]]></title>
    <url>%2F2017%2F05%2F17%2F%E9%85%8D%E7%BD%AEPostfix%2F</url>
    <content type="text"><![CDATA[使用postfix在ubuntu 配置代发邮箱 配置代发邮箱vim /etc/postfix/main.cf（Postfix主要配置文件，再其末尾添加以下配置） 123456789101112#指定默认的邮件发送服务器relayhost = [smtp.163.com]:25#激活sasl认证smtp_sasl_auth_enable = yes#指定sasl密码配置文件smtp_sasl_password_maps = hash:/etc/postfix/sasl_passwd#非匿名登录smtp_sasl_security_options = noanonymous#指定认证类型 （提示：需要yum安装cyrus-sasl-*组件，否则发邮件时会报错：no mechanism available）smtp_sasl_type = cyrus#linux用户与发件人的对应关系配置文件sender_canonical_maps = hash:/etc/postfix/sender_canonical vim /etc/postfix/sasl_passwd（邮箱账号和密码文件，每行一个。 创建好后需要使用postmap命令使配置文件生效） 1[smtp.163.com]:25 发件邮箱:邮箱密码 postmap /etc/postfix/sasl_passwd vim /etc/postfix/sender_canonical（linux用户和发件人对应关系，每行一个） 1root 发件邮箱 postmap /etc/postfix/sender_canonical 重启Postfix：service postfix restart 尝试发送邮件：echo &quot;hello world&quot; |mail -s test hung_z_h@qq.com (可以用 mailq 命令查看发送队列，清空mailq队列 ： postsuper -d ALL ) 邮件队列查看列出/打印当前邮件队列postqueue –p mailq 如果队列太长，可以使用tail管道读取。mailq | tail 清理队列postqueue -f 立即投递某domain.com域名的所有邮件postqueue -s domain.com 删除所有队列postsuper -d ALL 删除指定的消息postsuper -d messageid 重新排队邮件或者重新发送指定邮件postfix -r msgid 查找邮件版本postconf -d mail_version]]></content>
      <categories>
        <category>linux</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>postfix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法]]></title>
    <url>%2F2017%2F04%2F07%2FMarkDown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[MarkDown基础语法 基础语法标题123# This is an &lt;h1&gt; tag## This is an &lt;h2&gt; tag### This is an &lt;h3&gt; tag This is an &lt;h1&gt; tagThis is an &lt;h2&gt; tagThis is an &lt;h3&gt; tag加粗/斜体/删除线斜体12*This text will be italic*_This text will be italic_ This text will be italicThis text will be italic 加粗12**This text will be blod**__This text will be blod__ This text will be blodThis text will be blod 组合You can combine them 列表有序12341. Item11. Item2 1. Item2a --一个Tab 1. Item2b Item1 Item2 Item2a –一个Tab Item2b无序 Item1 Item2 Item2a Item2b图片12![CSDN Logo](/images/logo.png)Formate:![Alt Text](url) 链接12[GitHub](http://github.com) -automatic!Formate:[Text](url) GitHub -automatic! 引用1234As Kanye West said:&gt; We're living the future so&gt; the present is our past. As Kanye West said: We’re living the future sothe present is our past. 行内代码1I think you should use an `&lt;addr&gt;` element here instead. I think you should use an &lt;addr&gt; element here instead. 语法高亮12345function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; 使用四个空格function fancyAlert(arg) { if(arg) { $.facebox({div:&apos;#foo&apos;}) } } 任务列表1234- [x] @mentions, #refs, [links](), **formatting**, and &lt;del&gt;tags&lt;/del&gt; supported- [x] list syntax required (any unordered or ordered list supported)- [x] this is a complete item- [ ] this is an incomplete item @mentions, #refs, links, formatting, and tags supported list syntax required (any unordered or ordered list supported) this is a complete item this is an incomplete item表格123列1|列b-|-adjfadofafoa|dfasdfjkladfjajkkfklas 列1 列b adjfadofafoa dfasdfjkladfjajkkfklas 参考链接参考Github MarkDown语法]]></content>
      <categories>
        <category>工具</category>
        <category>脚本</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
